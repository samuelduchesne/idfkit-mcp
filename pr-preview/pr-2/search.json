{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"idfkit-mcp","text":"<p> 25 MCP tools  Schema-aware edits  Validation + references  Weather search + download  Simulation orchestration  Codex + Claude workflows</p>","path":["idfkit-mcp"],"tags":[]},{"location":"#idfkit-mcp","level":1,"title":"idfkit-mcp","text":"<p> A production-ready MCP server for EnergyPlus workflows: schema discovery, model editing, validation, weather acquisition, and simulation via idfkit. </p> <p> </p> <p>Install &amp; Configure  Tool Reference</p>","path":["idfkit-mcp"],"tags":[]},{"location":"#what-you-get","level":2,"title":"What You Get","text":"<ul> <li>A single MCP server that covers the EnergyPlus model lifecycle:</li> <li>schema exploration</li> <li>model read/write operations</li> <li>validation and dangling-reference checks</li> <li>weather station search and EPW download</li> <li>simulation runs and result summaries</li> <li>Predictable, structured tool responses for autonomous agents.</li> <li>Workflow compatibility across Codex, Claude, and other MCP-capable clients.</li> </ul>","path":["idfkit-mcp"],"tags":[]},{"location":"#recommended-tool-order","level":2,"title":"Recommended Tool Order","text":"<ol> <li><code>get_model_summary</code> or <code>new_model</code></li> <li><code>describe_object_type</code> before edits</li> <li><code>batch_add_objects</code> for bulk creation</li> <li><code>validate_model</code> after modifications</li> <li><code>run_simulation</code></li> <li><code>get_results_summary</code> and <code>list_output_variables</code></li> </ol>","path":["idfkit-mcp"],"tags":[]},{"location":"#quick-workflow-example","level":2,"title":"Quick Workflow Example","text":"<pre><code>1) new_model(version=\"24.1.0\")\n2) describe_object_type(object_type=\"Zone\")\n3) batch_add_objects(objects=[...])\n4) validate_model(check_references=True)\n5) download_weather_file(query=\"Chicago\")\n6) run_simulation(annual=True)\n7) get_results_summary()\n</code></pre>","path":["idfkit-mcp"],"tags":[]},{"location":"#explore-the-docs","level":2,"title":"Explore the Docs","text":"<ul> <li> <p> Get Started</p> <p>Install the server, configure MCP clients, and run your first end-to-end session.</p> <p> Get Started</p> </li> <li> <p> Agent Workflows</p> <p>Practical patterns for Codex, Claude, and multi-agent orchestration.</p> <p> Agent Workflows</p> </li> <li> <p> Tool Reference</p> <p>Parameter-by-parameter guidance for all tools and expected outputs.</p> <p> Tool Reference</p> </li> <li> <p> Concepts</p> <p>Understand state management, safety constraints, and failure semantics.</p> <p> Concepts</p> </li> <li> <p> Troubleshooting</p> <p>Resolve setup, schema, weather, and simulation issues quickly.</p> <p> Troubleshooting</p> </li> <li> <p> API Reference</p> <p>Module-level reference generated from source docstrings.</p> <p> API Reference</p> </li> </ul>","path":["idfkit-mcp"],"tags":[]},{"location":"api/","level":1,"title":"API Reference","text":"<p>This section is generated from source docstrings.</p>","path":["API Reference"],"tags":[]},{"location":"api/#modules","level":2,"title":"Modules","text":"<ul> <li>Server</li> <li>State</li> <li>Tools: Schema</li> <li>Tools: Read</li> <li>Tools: Write</li> <li>Tools: Validation</li> <li>Tools: Simulation</li> <li>Tools: Weather</li> </ul>","path":["API Reference"],"tags":[]},{"location":"api/server/","level":1,"title":"Server","text":"<p>FastMCP server for idfkit — EnergyPlus model authoring, validation, and simulation.</p>","path":["API Reference","Server"],"tags":[]},{"location":"api/server/#idfkit_mcp.server.create_server","level":2,"title":"<code>create_server(host='127.0.0.1', port=8000)</code>","text":"<p>Create a configured FastMCP instance and register all tools.</p> Source code in <code>src/idfkit_mcp/server.py</code> <pre><code>def create_server(host: str = \"127.0.0.1\", port: int = 8000) -&gt; FastMCP:\n    \"\"\"Create a configured FastMCP instance and register all tools.\"\"\"\n    server = FastMCP(\"idfkit\", instructions=_INSTRUCTIONS, host=host, port=port)\n\n    schema.register(server)\n    read.register(server)\n    write.register(server)\n    validation.register(server)\n    simulation.register(server)\n    weather.register(server)\n    return server\n</code></pre>","path":["API Reference","Server"],"tags":[]},{"location":"api/server/#idfkit_mcp.server.main","level":2,"title":"<code>main()</code>","text":"<p>Run the MCP server with configurable transport.</p> Source code in <code>src/idfkit_mcp/server.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Run the MCP server with configurable transport.\"\"\"\n    args = _parse_args()\n    server = create_server(host=args.host, port=args.port)\n\n    run_kwargs: dict[str, str | None] = {\"transport\": args.transport}\n    if args.transport != \"stdio\" and args.mount_path is not None:\n        run_kwargs[\"mount_path\"] = args.mount_path\n\n    server.run(**run_kwargs)  # type: ignore[arg-type]\n</code></pre>","path":["API Reference","Server"],"tags":[]},{"location":"api/state/","level":1,"title":"State","text":"<p>Server state management for the idfkit MCP server.</p>","path":["API Reference","State"],"tags":[]},{"location":"api/state/#idfkit_mcp.state.ServerState","level":2,"title":"<code>ServerState</code>  <code>dataclass</code>","text":"<p>Holds the active document, schema, and simulation result.</p> <p>MCP stdio transport is single-threaded, so a module-level instance is safe.</p> Source code in <code>src/idfkit_mcp/state.py</code> <pre><code>@dataclass\nclass ServerState:\n    \"\"\"Holds the active document, schema, and simulation result.\n\n    MCP stdio transport is single-threaded, so a module-level instance is safe.\n    \"\"\"\n\n    document: IDFDocument | None = None\n    schema: EpJSONSchema | None = None\n    file_path: Path | None = None\n    simulation_result: SimulationResult | None = None\n    weather_file: Path | None = None\n\n    def require_model(self) -&gt; IDFDocument:\n        \"\"\"Return the active document or raise a descriptive error.\"\"\"\n        if self.document is None:\n            msg = \"No model loaded. Use load_model or new_model first.\"\n            raise RuntimeError(msg)\n        return self.document\n\n    def require_schema(self) -&gt; EpJSONSchema:\n        \"\"\"Return the active schema or raise a descriptive error.\"\"\"\n        if self.schema is None:\n            msg = \"No schema loaded. Use load_model or new_model first.\"\n            raise RuntimeError(msg)\n        return self.schema\n\n    def get_or_load_schema(self, version: tuple[int, int, int] | None = None) -&gt; EpJSONSchema:\n        \"\"\"Return the active schema, or load one for the given version.\"\"\"\n        if version is not None:\n            return get_schema(version)\n        if self.schema is not None:\n            return self.schema\n        return get_schema(LATEST_VERSION)\n\n    def require_simulation_result(self) -&gt; SimulationResult:\n        \"\"\"Return the simulation result or raise a descriptive error.\"\"\"\n        if self.simulation_result is None:\n            msg = \"No simulation results available. Use run_simulation first.\"\n            raise RuntimeError(msg)\n        return self.simulation_result\n</code></pre>","path":["API Reference","State"],"tags":[]},{"location":"api/state/#idfkit_mcp.state.ServerState.get_or_load_schema","level":3,"title":"<code>get_or_load_schema(version=None)</code>","text":"<p>Return the active schema, or load one for the given version.</p> Source code in <code>src/idfkit_mcp/state.py</code> <pre><code>def get_or_load_schema(self, version: tuple[int, int, int] | None = None) -&gt; EpJSONSchema:\n    \"\"\"Return the active schema, or load one for the given version.\"\"\"\n    if version is not None:\n        return get_schema(version)\n    if self.schema is not None:\n        return self.schema\n    return get_schema(LATEST_VERSION)\n</code></pre>","path":["API Reference","State"],"tags":[]},{"location":"api/state/#idfkit_mcp.state.ServerState.require_model","level":3,"title":"<code>require_model()</code>","text":"<p>Return the active document or raise a descriptive error.</p> Source code in <code>src/idfkit_mcp/state.py</code> <pre><code>def require_model(self) -&gt; IDFDocument:\n    \"\"\"Return the active document or raise a descriptive error.\"\"\"\n    if self.document is None:\n        msg = \"No model loaded. Use load_model or new_model first.\"\n        raise RuntimeError(msg)\n    return self.document\n</code></pre>","path":["API Reference","State"],"tags":[]},{"location":"api/state/#idfkit_mcp.state.ServerState.require_schema","level":3,"title":"<code>require_schema()</code>","text":"<p>Return the active schema or raise a descriptive error.</p> Source code in <code>src/idfkit_mcp/state.py</code> <pre><code>def require_schema(self) -&gt; EpJSONSchema:\n    \"\"\"Return the active schema or raise a descriptive error.\"\"\"\n    if self.schema is None:\n        msg = \"No schema loaded. Use load_model or new_model first.\"\n        raise RuntimeError(msg)\n    return self.schema\n</code></pre>","path":["API Reference","State"],"tags":[]},{"location":"api/state/#idfkit_mcp.state.ServerState.require_simulation_result","level":3,"title":"<code>require_simulation_result()</code>","text":"<p>Return the simulation result or raise a descriptive error.</p> Source code in <code>src/idfkit_mcp/state.py</code> <pre><code>def require_simulation_result(self) -&gt; SimulationResult:\n    \"\"\"Return the simulation result or raise a descriptive error.\"\"\"\n    if self.simulation_result is None:\n        msg = \"No simulation results available. Use run_simulation first.\"\n        raise RuntimeError(msg)\n    return self.simulation_result\n</code></pre>","path":["API Reference","State"],"tags":[]},{"location":"api/state/#idfkit_mcp.state.get_state","level":2,"title":"<code>get_state()</code>","text":"<p>Return the module-level server state.</p> Source code in <code>src/idfkit_mcp/state.py</code> <pre><code>def get_state() -&gt; ServerState:\n    \"\"\"Return the module-level server state.\"\"\"\n    return _state\n</code></pre>","path":["API Reference","State"],"tags":[]},{"location":"api/tools-read/","level":1,"title":"Tools: Read","text":"<p>Model reading and inspection tools.</p>","path":["API Reference","Tools","Tools: Read"],"tags":[]},{"location":"api/tools-read/#idfkit_mcp.tools.read.get_model_summary","level":2,"title":"<code>get_model_summary()</code>","text":"<p>Get a summary of the currently loaded model.</p> <p>Returns version, total objects, zone count, and counts by group/type.</p> Source code in <code>src/idfkit_mcp/tools/read.py</code> <pre><code>@_safe_tool\ndef get_model_summary() -&gt; dict[str, Any]:\n    \"\"\"Get a summary of the currently loaded model.\n\n    Returns version, total objects, zone count, and counts by group/type.\n    \"\"\"\n    state = get_state()\n    doc = state.require_model()\n    return _build_summary(doc, state)\n</code></pre>","path":["API Reference","Tools","Tools: Read"],"tags":[]},{"location":"api/tools-read/#idfkit_mcp.tools.read.get_object","level":2,"title":"<code>get_object(object_type, name)</code>","text":"<p>Get all field values for a specific object.</p> <p>Parameters:</p> Name Type Description Default <code>object_type</code> <code>str</code> <p>The EnergyPlus object type.</p> required <code>name</code> <code>str</code> <p>The object name.</p> required Source code in <code>src/idfkit_mcp/tools/read.py</code> <pre><code>@_safe_tool\ndef get_object(object_type: str, name: str) -&gt; dict[str, Any]:\n    \"\"\"Get all field values for a specific object.\n\n    Args:\n        object_type: The EnergyPlus object type.\n        name: The object name.\n    \"\"\"\n    state = get_state()\n    doc = state.require_model()\n\n    if object_type not in doc:\n        return {\"error\": f\"No objects of type '{object_type}' in the model.\"}\n\n    collection = doc[object_type]\n    obj = collection.get(name)\n    if obj is None:\n        return {\"error\": f\"Object '{name}' not found in '{object_type}'.\"}\n\n    return serialize_object(obj)\n</code></pre>","path":["API Reference","Tools","Tools: Read"],"tags":[]},{"location":"api/tools-read/#idfkit_mcp.tools.read.get_references","level":2,"title":"<code>get_references(name)</code>","text":"<p>Get bidirectional references for an object name.</p> <p>Returns objects that reference this name, and names this object references.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The object name to check references for.</p> required Source code in <code>src/idfkit_mcp/tools/read.py</code> <pre><code>@_safe_tool\ndef get_references(name: str) -&gt; dict[str, Any]:\n    \"\"\"Get bidirectional references for an object name.\n\n    Returns objects that reference this name, and names this object references.\n\n    Args:\n        name: The object name to check references for.\n    \"\"\"\n    state = get_state()\n    doc = state.require_model()\n\n    # Objects that reference this name\n    referencing = doc.get_referencing(name)\n    referenced_by = [{\"object_type\": obj.obj_type, \"name\": obj.name} for obj in referencing]\n\n    # Find the object and get what it references\n    references: list[str] = []\n    target_obj = _find_object_by_name(doc, name)\n    if target_obj is not None:\n        refs = doc.get_references(target_obj)\n        references = sorted(refs)\n\n    return {\n        \"name\": name,\n        \"referenced_by\": referenced_by,\n        \"referenced_by_count\": len(referenced_by),\n        \"references\": references,\n        \"references_count\": len(references),\n    }\n</code></pre>","path":["API Reference","Tools","Tools: Read"],"tags":[]},{"location":"api/tools-read/#idfkit_mcp.tools.read.list_objects","level":2,"title":"<code>list_objects(object_type, limit=50)</code>","text":"<p>List objects of a given type from the loaded model.</p> <p>Returns object names and required field values in brief format.</p> <p>Parameters:</p> Name Type Description Default <code>object_type</code> <code>str</code> <p>The EnergyPlus object type (e.g. \"Zone\").</p> required <code>limit</code> <code>int</code> <p>Maximum number of objects to return (default 50).</p> <code>50</code> Source code in <code>src/idfkit_mcp/tools/read.py</code> <pre><code>@_safe_tool\ndef list_objects(object_type: str, limit: int = 50) -&gt; dict[str, Any]:\n    \"\"\"List objects of a given type from the loaded model.\n\n    Returns object names and required field values in brief format.\n\n    Args:\n        object_type: The EnergyPlus object type (e.g. \"Zone\").\n        limit: Maximum number of objects to return (default 50).\n    \"\"\"\n    state = get_state()\n    doc = state.require_model()\n\n    if object_type not in doc:\n        return {\"error\": f\"No objects of type '{object_type}' in the model.\"}\n\n    collection = doc[object_type]\n    total = len(collection)\n    objects = [serialize_object(obj, schema=state.schema, brief=True) for obj in list(collection)[:limit]]\n\n    return {\"object_type\": object_type, \"total\": total, \"returned\": len(objects), \"objects\": objects}\n</code></pre>","path":["API Reference","Tools","Tools: Read"],"tags":[]},{"location":"api/tools-read/#idfkit_mcp.tools.read.load_model","level":2,"title":"<code>load_model(file_path, version=None)</code>","text":"<p>Load an IDF or epJSON file as the active model.</p> <p>Auto-detects format by file extension (.idf or .epjson/.json).</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the IDF or epJSON file.</p> required <code>version</code> <code>str | None</code> <p>Optional version override as \"X.Y.Z\".</p> <code>None</code> Source code in <code>src/idfkit_mcp/tools/read.py</code> <pre><code>@_safe_tool\ndef load_model(file_path: str, version: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Load an IDF or epJSON file as the active model.\n\n    Auto-detects format by file extension (.idf or .epjson/.json).\n\n    Args:\n        file_path: Path to the IDF or epJSON file.\n        version: Optional version override as \"X.Y.Z\".\n    \"\"\"\n    from pathlib import Path\n\n    from idfkit import load_epjson, load_idf\n\n    state = get_state()\n    path = Path(file_path)\n    ver = None\n    if version is not None:\n        parts = version.split(\".\")\n        ver = (int(parts[0]), int(parts[1]), int(parts[2]))\n\n    if path.suffix.lower() in (\".epjson\", \".json\"):\n        doc = load_epjson(str(path), version=ver)\n    else:\n        doc = load_idf(str(path), version=ver)\n\n    state.document = doc\n    state.schema = doc.schema\n    state.file_path = path\n    state.simulation_result = None\n\n    return _build_summary(doc, state)\n</code></pre>","path":["API Reference","Tools","Tools: Read"],"tags":[]},{"location":"api/tools-read/#idfkit_mcp.tools.read.register","level":2,"title":"<code>register(mcp)</code>","text":"<p>Register read tools on the MCP server.</p> Source code in <code>src/idfkit_mcp/tools/read.py</code> <pre><code>def register(mcp: FastMCP) -&gt; None:\n    \"\"\"Register read tools on the MCP server.\"\"\"\n    mcp.tool()(load_model)\n    mcp.tool()(get_model_summary)\n    mcp.tool()(list_objects)\n    mcp.tool()(get_object)\n    mcp.tool()(search_objects)\n    mcp.tool()(get_references)\n</code></pre>","path":["API Reference","Tools","Tools: Read"],"tags":[]},{"location":"api/tools-read/#idfkit_mcp.tools.read.search_objects","level":2,"title":"<code>search_objects(query, object_type=None, limit=20)</code>","text":"<p>Search for objects by name or field values.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search string (case-insensitive substring match on name and string fields).</p> required <code>object_type</code> <code>str | None</code> <p>Optionally restrict search to a specific type.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum results to return (default 20).</p> <code>20</code> Source code in <code>src/idfkit_mcp/tools/read.py</code> <pre><code>@_safe_tool\ndef search_objects(query: str, object_type: str | None = None, limit: int = 20) -&gt; dict[str, Any]:\n    \"\"\"Search for objects by name or field values.\n\n    Args:\n        query: Search string (case-insensitive substring match on name and string fields).\n        object_type: Optionally restrict search to a specific type.\n        limit: Maximum results to return (default 20).\n    \"\"\"\n    state = get_state()\n    doc = state.require_model()\n    query_lower = query.lower()\n\n    matches: list[dict[str, Any]] = []\n    for obj in doc.all_objects:\n        if object_type is not None and obj.obj_type != object_type:\n            continue\n        if _matches_query(obj, query_lower):\n            matches.append({\"object_type\": obj.obj_type, \"name\": obj.name})\n            if len(matches) &gt;= limit:\n                break\n\n    return {\"query\": query, \"count\": len(matches), \"matches\": matches}\n</code></pre>","path":["API Reference","Tools","Tools: Read"],"tags":[]},{"location":"api/tools-schema/","level":1,"title":"Tools: Schema","text":"<p>Schema exploration tools — work without a loaded model.</p>","path":["API Reference","Tools","Tools: Schema"],"tags":[]},{"location":"api/tools-schema/#idfkit_mcp.tools.schema.describe_object_type","level":2,"title":"<code>describe_object_type(object_type, version=None)</code>","text":"<p>Get full field schema for an EnergyPlus object type.</p> <p>Returns field names, types, constraints, defaults, references, and memo. Call this before creating or editing objects to know valid fields.</p> <p>Parameters:</p> Name Type Description Default <code>object_type</code> <code>str</code> <p>The object type name (e.g. \"Zone\", \"Material\").</p> required <code>version</code> <code>str | None</code> <p>EnergyPlus version as \"X.Y.Z\" (default: latest or loaded model version).</p> <code>None</code> Source code in <code>src/idfkit_mcp/tools/schema.py</code> <pre><code>@_safe_tool\ndef describe_object_type(object_type: str, version: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Get full field schema for an EnergyPlus object type.\n\n    Returns field names, types, constraints, defaults, references, and memo.\n    Call this before creating or editing objects to know valid fields.\n\n    Args:\n        object_type: The object type name (e.g. \"Zone\", \"Material\").\n        version: EnergyPlus version as \"X.Y.Z\" (default: latest or loaded model version).\n    \"\"\"\n    from idfkit.introspection import describe_object_type as _describe\n\n    state = get_state()\n    schema = state.get_or_load_schema(_parse_version(version))\n    desc = _describe(schema, object_type)\n    return serialize_object_description(desc)\n</code></pre>","path":["API Reference","Tools","Tools: Schema"],"tags":[]},{"location":"api/tools-schema/#idfkit_mcp.tools.schema.get_available_references","level":2,"title":"<code>get_available_references(object_type, field_name)</code>","text":"<p>Get valid object names for a reference field from the loaded model.</p> <p>Use this to find valid values when setting reference fields like zone_name, construction_name, etc.</p> <p>Parameters:</p> Name Type Description Default <code>object_type</code> <code>str</code> <p>The object type containing the field.</p> required <code>field_name</code> <code>str</code> <p>The field name to check.</p> required Source code in <code>src/idfkit_mcp/tools/schema.py</code> <pre><code>@_safe_tool\ndef get_available_references(object_type: str, field_name: str) -&gt; dict[str, Any]:\n    \"\"\"Get valid object names for a reference field from the loaded model.\n\n    Use this to find valid values when setting reference fields like zone_name,\n    construction_name, etc.\n\n    Args:\n        object_type: The object type containing the field.\n        field_name: The field name to check.\n    \"\"\"\n    state = get_state()\n    doc = state.require_model()\n    schema = state.require_schema()\n\n    object_lists = schema.get_field_object_list(object_type, field_name)\n    if not object_lists:\n        return {\"error\": f\"Field '{field_name}' on '{object_type}' is not a reference field.\"}\n\n    available: dict[str, list[str]] = {}\n    for list_name in object_lists:\n        provider_types = schema.get_types_providing_reference(list_name)\n        names: list[str] = []\n        for ptype in provider_types:\n            if ptype in doc:\n                for obj in doc[ptype]:\n                    if obj.name:\n                        names.append(obj.name)\n        if names:\n            available[list_name] = sorted(names)\n\n    all_names = sorted({n for names in available.values() for n in names})\n    return {\n        \"object_type\": object_type,\n        \"field_name\": field_name,\n        \"available_names\": all_names,\n        \"by_reference_list\": available,\n    }\n</code></pre>","path":["API Reference","Tools","Tools: Schema"],"tags":[]},{"location":"api/tools-schema/#idfkit_mcp.tools.schema.list_object_types","level":2,"title":"<code>list_object_types(group=None, version=None)</code>","text":"<p>List all EnergyPlus object types, optionally filtered by group.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str | None</code> <p>Filter to a specific IDD group (e.g. \"Thermal Zones and Surfaces\").</p> <code>None</code> <code>version</code> <code>str | None</code> <p>EnergyPlus version as \"X.Y.Z\" (default: latest or loaded model version).</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Groups with their object type names.</p> Source code in <code>src/idfkit_mcp/tools/schema.py</code> <pre><code>@_safe_tool\ndef list_object_types(group: str | None = None, version: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"List all EnergyPlus object types, optionally filtered by group.\n\n    Args:\n        group: Filter to a specific IDD group (e.g. \"Thermal Zones and Surfaces\").\n        version: EnergyPlus version as \"X.Y.Z\" (default: latest or loaded model version).\n\n    Returns:\n        Groups with their object type names.\n    \"\"\"\n    state = get_state()\n    schema = state.get_or_load_schema(_parse_version(version))\n\n    groups: dict[str, list[str]] = {}\n    for obj_type in schema.object_types:\n        g = schema.get_group(obj_type) or \"Ungrouped\"\n        if group is not None and g.lower() != group.lower():\n            continue\n        groups.setdefault(g, []).append(obj_type)\n\n    return {\n        \"total_types\": sum(len(v) for v in groups.values()),\n        \"groups\": {g: {\"count\": len(types), \"types\": types} for g, types in sorted(groups.items())},\n    }\n</code></pre>","path":["API Reference","Tools","Tools: Schema"],"tags":[]},{"location":"api/tools-schema/#idfkit_mcp.tools.schema.register","level":2,"title":"<code>register(mcp)</code>","text":"<p>Register schema tools on the MCP server.</p> Source code in <code>src/idfkit_mcp/tools/schema.py</code> <pre><code>def register(mcp: FastMCP) -&gt; None:\n    \"\"\"Register schema tools on the MCP server.\"\"\"\n    mcp.tool()(list_object_types)\n    mcp.tool()(describe_object_type)\n    mcp.tool()(search_schema)\n    mcp.tool()(get_available_references)\n</code></pre>","path":["API Reference","Tools","Tools: Schema"],"tags":[]},{"location":"api/tools-schema/#idfkit_mcp.tools.schema.search_schema","level":2,"title":"<code>search_schema(query, version=None)</code>","text":"<p>Search for EnergyPlus object types by name or description.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search string (case-insensitive substring match).</p> required <code>version</code> <code>str | None</code> <p>EnergyPlus version as \"X.Y.Z\" (default: latest or loaded model version).</p> <code>None</code> Source code in <code>src/idfkit_mcp/tools/schema.py</code> <pre><code>@_safe_tool\ndef search_schema(query: str, version: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Search for EnergyPlus object types by name or description.\n\n    Args:\n        query: Search string (case-insensitive substring match).\n        version: EnergyPlus version as \"X.Y.Z\" (default: latest or loaded model version).\n    \"\"\"\n    state = get_state()\n    schema = state.get_or_load_schema(_parse_version(version))\n    query_lower = query.lower()\n\n    matches: list[dict[str, Any]] = []\n    for obj_type in schema.object_types:\n        memo = schema.get_object_memo(obj_type) or \"\"\n        if query_lower in obj_type.lower() or query_lower in memo.lower():\n            group = schema.get_group(obj_type) or \"Ungrouped\"\n            matches.append({\n                \"object_type\": obj_type,\n                \"group\": group,\n                \"memo\": memo[:200] if memo else None,\n            })\n\n    return {\"query\": query, \"count\": len(matches), \"matches\": matches}\n</code></pre>","path":["API Reference","Tools","Tools: Schema"],"tags":[]},{"location":"api/tools-simulation/","level":1,"title":"Tools: Simulation","text":"<p>Simulation tools.</p>","path":["API Reference","Tools","Tools: Simulation"],"tags":[]},{"location":"api/tools-simulation/#idfkit_mcp.tools.simulation.export_timeseries","level":2,"title":"<code>export_timeseries(variable_name, key_value='*', frequency=None, environment=None, output_path=None)</code>","text":"<p>Export time series data from the last simulation to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>The output variable name (e.g. \"Zone Mean Air Temperature\").</p> required <code>key_value</code> <code>str</code> <p>Key value such as zone or surface name. Use \"*\" for environment-level variables.</p> <code>'*'</code> <code>frequency</code> <code>str | None</code> <p>Optional frequency filter (e.g. \"Hourly\").</p> <code>None</code> <code>environment</code> <code>Literal['sizing', 'annual'] | None</code> <p>Filter by environment type: \"sizing\" or \"annual\".</p> <code>None</code> <code>output_path</code> <code>str | None</code> <p>Output CSV file path. Defaults to a file in the simulation output directory.</p> <code>None</code> Source code in <code>src/idfkit_mcp/tools/simulation.py</code> <pre><code>@_safe_tool\ndef export_timeseries(\n    variable_name: str,\n    key_value: str = \"*\",\n    frequency: str | None = None,\n    environment: Literal[\"sizing\", \"annual\"] | None = None,\n    output_path: str | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Export time series data from the last simulation to a CSV file.\n\n    Args:\n        variable_name: The output variable name (e.g. \"Zone Mean Air Temperature\").\n        key_value: Key value such as zone or surface name. Use \"*\" for environment-level variables.\n        frequency: Optional frequency filter (e.g. \"Hourly\").\n        environment: Filter by environment type: \"sizing\" or \"annual\".\n        output_path: Output CSV file path. Defaults to a file in the simulation output directory.\n    \"\"\"\n    import csv\n    import re\n    from pathlib import Path\n\n    state = get_state()\n    result = state.require_simulation_result()\n\n    sql = result.sql\n    if sql is None:\n        return {\"error\": \"No SQL output available. The simulation may not have produced an .sql file.\"}\n\n    ts = sql.get_timeseries(\n        variable_name=variable_name,\n        key_value=key_value,\n        frequency=frequency,\n        environment=environment,\n    )\n\n    if output_path is not None:\n        csv_path = Path(output_path)\n    else:\n        safe_name = re.sub(r\"[^\\w]+\", \"_\", variable_name).strip(\"_\").lower()\n        csv_path = result.run_dir / f\"timeseries_{safe_name}.csv\"\n\n    with csv_path.open(\"w\", newline=\"\") as f:\n        writer = csv.writer(f)\n        writer.writerow([\"timestamp\", ts.variable_name + f\" [{ts.units}]\"])\n        for i in range(len(ts.values)):\n            writer.writerow([ts.timestamps[i].isoformat(), ts.values[i]])\n\n    return {\n        \"path\": str(csv_path),\n        \"variable_name\": ts.variable_name,\n        \"key_value\": ts.key_value,\n        \"units\": ts.units,\n        \"frequency\": ts.frequency,\n        \"rows\": len(ts.values),\n    }\n</code></pre>","path":["API Reference","Tools","Tools: Simulation"],"tags":[]},{"location":"api/tools-simulation/#idfkit_mcp.tools.simulation.get_results_summary","level":2,"title":"<code>get_results_summary()</code>","text":"<p>Get a summary of the last simulation results.</p> <p>Returns energy metrics, error counts, and key tables from the HTML output.</p> Source code in <code>src/idfkit_mcp/tools/simulation.py</code> <pre><code>@_safe_tool\ndef get_results_summary() -&gt; dict[str, Any]:\n    \"\"\"Get a summary of the last simulation results.\n\n    Returns energy metrics, error counts, and key tables from the HTML output.\n    \"\"\"\n    state = get_state()\n    result = state.require_simulation_result()\n\n    summary: dict[str, Any] = {\n        \"success\": result.success,\n        \"runtime_seconds\": round(result.runtime_seconds, 2),\n        \"output_directory\": str(result.run_dir),\n    }\n\n    errors = result.errors\n    summary[\"errors\"] = {\n        \"fatal\": errors.fatal_count,\n        \"severe\": errors.severe_count,\n        \"warnings\": errors.warning_count,\n        \"summary\": errors.summary(),\n    }\n\n    if errors.has_fatal or errors.has_severe:\n        severe_msgs = [{\"message\": m.message, \"details\": list(m.details)} for m in errors.severe[:10]]\n        fatal_msgs = [{\"message\": m.message, \"details\": list(m.details)} for m in errors.fatal]\n        summary[\"fatal_messages\"] = fatal_msgs\n        summary[\"severe_messages\"] = severe_msgs\n\n    html = result.html\n    if html is not None:\n        tables_summary: list[dict[str, Any]] = []\n        for table in html.tables[:20]:\n            table_info: dict[str, Any] = {\n                \"title\": table.title,\n                \"report\": table.report_name,\n                \"for\": table.for_string,\n            }\n            table_dict = table.to_dict()\n            if table_dict:\n                table_info[\"data\"] = table_dict\n            tables_summary.append(table_info)\n        summary[\"tables\"] = tables_summary\n\n    return summary\n</code></pre>","path":["API Reference","Tools","Tools: Simulation"],"tags":[]},{"location":"api/tools-simulation/#idfkit_mcp.tools.simulation.list_output_variables","level":2,"title":"<code>list_output_variables(search=None, limit=50)</code>","text":"<p>List available output variables from the last simulation.</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <code>str | None</code> <p>Optional regex pattern to filter variables by name.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of results (default 50).</p> <code>50</code> Source code in <code>src/idfkit_mcp/tools/simulation.py</code> <pre><code>@_safe_tool\ndef list_output_variables(search: str | None = None, limit: int = 50) -&gt; dict[str, Any]:\n    \"\"\"List available output variables from the last simulation.\n\n    Args:\n        search: Optional regex pattern to filter variables by name.\n        limit: Maximum number of results (default 50).\n    \"\"\"\n    state = get_state()\n    result = state.require_simulation_result()\n\n    variables = result.variables\n    if variables is None:\n        return {\"error\": \"No output variable index available. The simulation may not have produced .rdd/.mdd files.\"}\n\n    from idfkit.simulation.parsers.rdd import OutputVariable\n\n    all_items = variables.search(search) if search else [*variables.variables, *variables.meters]\n\n    limited = all_items[:limit]\n    serialized: list[dict[str, str]] = []\n    for item in limited:\n        entry: dict[str, str] = {\"name\": item.name, \"units\": item.units}\n        if isinstance(item, OutputVariable):\n            entry[\"key\"] = item.key\n            entry[\"type\"] = \"variable\"\n        else:\n            entry[\"type\"] = \"meter\"\n        serialized.append(entry)\n\n    total = len(variables.variables) + len(variables.meters)\n    return {\"total_available\": total, \"returned\": len(serialized), \"variables\": serialized}\n</code></pre>","path":["API Reference","Tools","Tools: Simulation"],"tags":[]},{"location":"api/tools-simulation/#idfkit_mcp.tools.simulation.query_timeseries","level":2,"title":"<code>query_timeseries(variable_name, key_value='*', frequency=None, environment=None, limit=24)</code>","text":"<p>Query time series data from the last simulation's SQL output.</p> <p>Returns the first <code>limit</code> data points inline for quick inspection.</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>The output variable name (e.g. \"Zone Mean Air Temperature\").</p> required <code>key_value</code> <code>str</code> <p>Key value such as zone or surface name. Use \"*\" for environment-level variables.</p> <code>'*'</code> <code>frequency</code> <code>str | None</code> <p>Optional frequency filter (e.g. \"Hourly\").</p> <code>None</code> <code>environment</code> <code>Literal['sizing', 'annual'] | None</code> <p>Filter by environment type: \"sizing\" or \"annual\".</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of data points to return (default 24).</p> <code>24</code> Source code in <code>src/idfkit_mcp/tools/simulation.py</code> <pre><code>@_safe_tool\ndef query_timeseries(\n    variable_name: str,\n    key_value: str = \"*\",\n    frequency: str | None = None,\n    environment: Literal[\"sizing\", \"annual\"] | None = None,\n    limit: int = 24,\n) -&gt; dict[str, Any]:\n    \"\"\"Query time series data from the last simulation's SQL output.\n\n    Returns the first `limit` data points inline for quick inspection.\n\n    Args:\n        variable_name: The output variable name (e.g. \"Zone Mean Air Temperature\").\n        key_value: Key value such as zone or surface name. Use \"*\" for environment-level variables.\n        frequency: Optional frequency filter (e.g. \"Hourly\").\n        environment: Filter by environment type: \"sizing\" or \"annual\".\n        limit: Maximum number of data points to return (default 24).\n    \"\"\"\n    state = get_state()\n    result = state.require_simulation_result()\n\n    sql = result.sql\n    if sql is None:\n        return {\"error\": \"No SQL output available. The simulation may not have produced an .sql file.\"}\n\n    ts = sql.get_timeseries(\n        variable_name=variable_name,\n        key_value=key_value,\n        frequency=frequency,\n        environment=environment,\n    )\n\n    rows = [\n        {\"timestamp\": ts.timestamps[i].isoformat(), \"value\": ts.values[i]} for i in range(min(limit, len(ts.values)))\n    ]\n\n    return {\n        \"variable_name\": ts.variable_name,\n        \"key_value\": ts.key_value,\n        \"units\": ts.units,\n        \"frequency\": ts.frequency,\n        \"total_points\": len(ts.values),\n        \"returned\": len(rows),\n        \"data\": rows,\n    }\n</code></pre>","path":["API Reference","Tools","Tools: Simulation"],"tags":[]},{"location":"api/tools-simulation/#idfkit_mcp.tools.simulation.register","level":2,"title":"<code>register(mcp)</code>","text":"<p>Register simulation tools on the MCP server.</p> Source code in <code>src/idfkit_mcp/tools/simulation.py</code> <pre><code>def register(mcp: FastMCP) -&gt; None:\n    \"\"\"Register simulation tools on the MCP server.\"\"\"\n    mcp.tool()(run_simulation)\n    mcp.tool()(get_results_summary)\n    mcp.tool()(list_output_variables)\n    mcp.tool()(query_timeseries)\n    mcp.tool()(export_timeseries)\n</code></pre>","path":["API Reference","Tools","Tools: Simulation"],"tags":[]},{"location":"api/tools-simulation/#idfkit_mcp.tools.simulation.run_simulation","level":2,"title":"<code>run_simulation(weather_file=None, design_day=False, annual=False, energyplus_dir=None, energyplus_version=None, output_directory=None)</code>","text":"<p>Run an EnergyPlus simulation on the loaded model.</p> <p>Parameters:</p> Name Type Description Default <code>weather_file</code> <code>str | None</code> <p>Path to EPW weather file. Uses previously downloaded file if None.</p> <code>None</code> <code>design_day</code> <code>bool</code> <p>Run design-day-only simulation.</p> <code>False</code> <code>annual</code> <code>bool</code> <p>Run annual simulation.</p> <code>False</code> <code>energyplus_dir</code> <code>str | None</code> <p>Optional explicit EnergyPlus installation directory or executable path.</p> <code>None</code> <code>energyplus_version</code> <code>str | None</code> <p>Optional EnergyPlus version filter (e.g. \"25.1.0\").</p> <code>None</code> <code>output_directory</code> <code>str | None</code> <p>Optional explicit output directory for simulation results.</p> <code>None</code> Source code in <code>src/idfkit_mcp/tools/simulation.py</code> <pre><code>@_safe_tool\ndef run_simulation(\n    weather_file: str | None = None,\n    design_day: bool = False,\n    annual: bool = False,\n    energyplus_dir: str | None = None,\n    energyplus_version: str | None = None,\n    output_directory: str | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Run an EnergyPlus simulation on the loaded model.\n\n    Args:\n        weather_file: Path to EPW weather file. Uses previously downloaded file if None.\n        design_day: Run design-day-only simulation.\n        annual: Run annual simulation.\n        energyplus_dir: Optional explicit EnergyPlus installation directory or executable path.\n        energyplus_version: Optional EnergyPlus version filter (e.g. \"25.1.0\").\n        output_directory: Optional explicit output directory for simulation results.\n    \"\"\"\n    from pathlib import Path\n\n    from idfkit.simulation.config import find_energyplus\n    from idfkit.simulation.runner import simulate\n\n    state = get_state()\n    doc = state.require_model()\n\n    epw_path: Path | None = None\n    if weather_file is not None:\n        epw_path = Path(weather_file)\n    elif state.weather_file is not None:\n        epw_path = state.weather_file\n\n    if epw_path is None and not design_day:\n        return {\n            \"error\": \"No weather file specified. Provide weather_file or use download_weather_file first, or set design_day=True.\"\n        }\n\n    config = find_energyplus(path=energyplus_dir, version=energyplus_version)\n\n    output_dir = Path(output_directory) if output_directory is not None else None\n    weather = epw_path if epw_path is not None else \"\"\n    result = simulate(\n        doc, weather=weather, design_day=design_day, annual=annual, energyplus=config, output_dir=output_dir\n    )\n\n    state.simulation_result = result\n\n    errors = result.errors\n\n    error_detail: dict[str, Any] = {\n        \"fatal\": errors.fatal_count,\n        \"severe\": errors.severe_count,\n        \"warnings\": errors.warning_count,\n    }\n    if errors.has_fatal:\n        error_detail[\"fatal_messages\"] = [{\"message\": m.message, \"details\": list(m.details)} for m in errors.fatal]\n    if errors.has_severe:\n        error_detail[\"severe_messages\"] = [\n            {\"message\": m.message, \"details\": list(m.details)} for m in errors.severe[:10]\n        ]\n    if errors.warning_count &gt; 0:\n        error_detail[\"warning_messages\"] = [\n            {\"message\": m.message, \"details\": list(m.details)} for m in errors.warnings[:10]\n        ]\n\n    return {\n        \"success\": result.success,\n        \"runtime_seconds\": round(result.runtime_seconds, 2),\n        \"output_directory\": str(result.run_dir),\n        \"energyplus\": {\n            \"version\": \".\".join(str(part) for part in config.version),\n            \"install_dir\": str(config.install_dir),\n            \"executable\": str(config.executable),\n        },\n        \"errors\": error_detail,\n        \"simulation_complete\": errors.simulation_complete,\n    }\n</code></pre>","path":["API Reference","Tools","Tools: Simulation"],"tags":[]},{"location":"api/tools-validation/","level":1,"title":"Tools: Validation","text":"<p>Model validation tools.</p>","path":["API Reference","Tools","Tools: Validation"],"tags":[]},{"location":"api/tools-validation/#idfkit_mcp.tools.validation.register","level":2,"title":"<code>register(mcp)</code>","text":"<p>Register validation tools on the MCP server.</p> Source code in <code>src/idfkit_mcp/tools/validation.py</code> <pre><code>def register(mcp: FastMCP) -&gt; None:\n    \"\"\"Register validation tools on the MCP server.\"\"\"\n\n    @mcp.tool()\n    def validate_model(object_types: list[str] | None = None, check_references: bool = True) -&gt; dict[str, Any]:\n        \"\"\"Validate the loaded model against the EnergyPlus schema.\n\n        Args:\n            object_types: Only validate specific types (default: all).\n            check_references: Whether to check reference integrity (default: True).\n        \"\"\"\n        try:\n            from idfkit import validate_document\n\n            state = get_state()\n            doc = state.require_model()\n            result = validate_document(doc, check_references=check_references, object_types=object_types)\n            return serialize_validation_result(result)\n        except Exception as e:\n            return format_error(e)\n\n    @mcp.tool()\n    def check_references() -&gt; dict[str, Any]:\n        \"\"\"Check for dangling references in the loaded model.\n\n        Returns a list of references that point to non-existent objects.\n        \"\"\"\n        try:\n            state = get_state()\n            doc = state.require_model()\n\n            valid_names: set[str] = set()\n            for collection in doc.collections.values():\n                for obj in collection:\n                    if obj.name:\n                        valid_names.add(obj.name.upper())\n\n            dangling: list[dict[str, str]] = []\n            for obj, field_name, target in doc.references.get_dangling_references(valid_names):\n                dangling.append({\n                    \"source_type\": obj.obj_type,\n                    \"source_name\": obj.name,\n                    \"field\": field_name,\n                    \"missing_target\": target,\n                })\n\n            return {\"dangling_count\": len(dangling), \"dangling_references\": dangling}\n        except Exception as e:\n            return format_error(e)\n</code></pre>","path":["API Reference","Tools","Tools: Validation"],"tags":[]},{"location":"api/tools-weather/","level":1,"title":"Tools: Weather","text":"<p>Weather station search and download tools.</p>","path":["API Reference","Tools","Tools: Weather"],"tags":[]},{"location":"api/tools-weather/#idfkit_mcp.tools.weather.download_weather_file","level":2,"title":"<code>download_weather_file(wmo=None, query=None, country=None, state=None)</code>","text":"<p>Download an EPW weather file for simulation.</p> <p>The downloaded file path is stored for reuse with run_simulation.</p> <p>Parameters:</p> Name Type Description Default <code>wmo</code> <code>str | None</code> <p>WMO station number to download directly.</p> <code>None</code> <code>query</code> <code>str | None</code> <p>Search text to find and download the best match.</p> <code>None</code> <code>country</code> <code>str | None</code> <p>Filter by country code (e.g. \"USA\").</p> <code>None</code> <code>state</code> <code>str | None</code> <p>Filter by state/province code (e.g. \"MA\").</p> <code>None</code> Source code in <code>src/idfkit_mcp/tools/weather.py</code> <pre><code>@_safe_tool\ndef download_weather_file(\n    wmo: str | None = None,\n    query: str | None = None,\n    country: str | None = None,\n    state: str | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Download an EPW weather file for simulation.\n\n    The downloaded file path is stored for reuse with run_simulation.\n\n    Args:\n        wmo: WMO station number to download directly.\n        query: Search text to find and download the best match.\n        country: Filter by country code (e.g. \"USA\").\n        state: Filter by state/province code (e.g. \"MA\").\n    \"\"\"\n    from idfkit.weather import StationIndex, WeatherDownloader\n\n    index = StationIndex.load()\n\n    if query is not None:\n        results = index.search(query, limit=30)\n        station = None\n        for r in results:\n            if not _matches_filters(r.station, country, state):\n                continue\n            station = r.station\n            break\n        if station is None:\n            return {\"error\": f\"No weather stations found for query '{query}'.\"}\n    elif wmo is not None:\n        results = index.search(wmo, limit=10)\n        station = None\n        for r in results:\n            if r.station.wmo == wmo:\n                station = r.station\n                break\n        if station is None:\n            return {\"error\": f\"No weather station found with WMO '{wmo}'.\"}\n    else:\n        return {\"error\": \"Provide either 'wmo' or 'query' to identify the weather station.\"}\n\n    downloader = WeatherDownloader()\n    files = downloader.download(station)\n\n    server_state = get_state()\n    server_state.weather_file = files.epw\n\n    return {\n        \"status\": \"downloaded\",\n        \"station\": serialize_station(station),\n        \"epw_path\": str(files.epw),\n        \"ddy_path\": str(files.ddy),\n    }\n</code></pre>","path":["API Reference","Tools","Tools: Weather"],"tags":[]},{"location":"api/tools-weather/#idfkit_mcp.tools.weather.register","level":2,"title":"<code>register(mcp)</code>","text":"<p>Register weather tools on the MCP server.</p> Source code in <code>src/idfkit_mcp/tools/weather.py</code> <pre><code>def register(mcp: FastMCP) -&gt; None:\n    \"\"\"Register weather tools on the MCP server.\"\"\"\n    mcp.tool()(search_weather_stations)\n    mcp.tool()(download_weather_file)\n</code></pre>","path":["API Reference","Tools","Tools: Weather"],"tags":[]},{"location":"api/tools-weather/#idfkit_mcp.tools.weather.search_weather_stations","level":2,"title":"<code>search_weather_stations(query=None, latitude=None, longitude=None, country=None, state=None, limit=10)</code>","text":"<p>Search for weather stations by name/location or coordinates.</p> <p>Provide either a text query or latitude/longitude for spatial search.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | None</code> <p>Search text (city, airport code, etc.).</p> <code>None</code> <code>latitude</code> <code>float | None</code> <p>Latitude for nearest-station search.</p> <code>None</code> <code>longitude</code> <code>float | None</code> <p>Longitude for nearest-station search.</p> <code>None</code> <code>country</code> <code>str | None</code> <p>Filter by country code (e.g. \"USA\").</p> <code>None</code> <code>state</code> <code>str | None</code> <p>Filter by state/province code (e.g. \"MA\").</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum results (default 10).</p> <code>10</code> Source code in <code>src/idfkit_mcp/tools/weather.py</code> <pre><code>@_safe_tool\ndef search_weather_stations(\n    query: str | None = None,\n    latitude: float | None = None,\n    longitude: float | None = None,\n    country: str | None = None,\n    state: str | None = None,\n    limit: int = 10,\n) -&gt; dict[str, Any]:\n    \"\"\"Search for weather stations by name/location or coordinates.\n\n    Provide either a text query or latitude/longitude for spatial search.\n\n    Args:\n        query: Search text (city, airport code, etc.).\n        latitude: Latitude for nearest-station search.\n        longitude: Longitude for nearest-station search.\n        country: Filter by country code (e.g. \"USA\").\n        state: Filter by state/province code (e.g. \"MA\").\n        limit: Maximum results (default 10).\n    \"\"\"\n    from idfkit.weather import StationIndex\n\n    index = StationIndex.load()\n\n    if latitude is not None and longitude is not None:\n        spatial_results = index.nearest(latitude, longitude, limit=limit)\n        spatial_stations: list[dict[str, Any]] = []\n        for r in spatial_results:\n            if not _matches_filters(r.station, country, state):\n                continue\n            spatial_stations.append({\n                **serialize_station(r.station),\n                \"distance_km\": round(r.distance_km, 1),\n            })\n        return {\n            \"search_type\": \"spatial\",\n            \"count\": len(spatial_stations),\n            \"stations\": spatial_stations[:limit],\n        }\n\n    if query is not None:\n        search_results = index.search(query, limit=limit * 3)\n        text_stations: list[dict[str, Any]] = []\n        for r in search_results:\n            if not _matches_filters(r.station, country, state):\n                continue\n            text_stations.append({\n                **serialize_station(r.station),\n                \"score\": round(r.score, 3),\n                \"match_field\": r.match_field,\n            })\n            if len(text_stations) &gt;= limit:\n                break\n        return {\n            \"search_type\": \"text\",\n            \"query\": query,\n            \"count\": len(text_stations),\n            \"stations\": text_stations,\n        }\n\n    return {\"error\": \"Provide either 'query' for text search or 'latitude'/'longitude' for spatial search.\"}\n</code></pre>","path":["API Reference","Tools","Tools: Weather"],"tags":[]},{"location":"api/tools-write/","level":1,"title":"Tools: Write","text":"<p>Model creation and editing tools.</p>","path":["API Reference","Tools","Tools: Write"],"tags":[]},{"location":"api/tools-write/#idfkit_mcp.tools.write.add_object","level":2,"title":"<code>add_object(object_type, name='', fields=None)</code>","text":"<p>Add a new object to the model.</p> <p>Call describe_object_type first to see valid fields for this type.</p> <p>Parameters:</p> Name Type Description Default <code>object_type</code> <code>str</code> <p>The EnergyPlus object type (e.g. \"Zone\", \"Material\").</p> required <code>name</code> <code>str</code> <p>Object name (empty string for unnamed types).</p> <code>''</code> <code>fields</code> <code>dict[str, Any] | None</code> <p>Field values as {field_name: value}.</p> <code>None</code> Source code in <code>src/idfkit_mcp/tools/write.py</code> <pre><code>@_safe_tool\ndef add_object(object_type: str, name: str = \"\", fields: dict[str, Any] | None = None) -&gt; dict[str, Any]:\n    \"\"\"Add a new object to the model.\n\n    Call describe_object_type first to see valid fields for this type.\n\n    Args:\n        object_type: The EnergyPlus object type (e.g. \"Zone\", \"Material\").\n        name: Object name (empty string for unnamed types).\n        fields: Field values as {field_name: value}.\n    \"\"\"\n    state = get_state()\n    doc = state.require_model()\n    kwargs = fields or {}\n    obj = doc.add(object_type, name, **kwargs)\n    return serialize_object(obj)\n</code></pre>","path":["API Reference","Tools","Tools: Write"],"tags":[]},{"location":"api/tools-write/#idfkit_mcp.tools.write.batch_add_objects","level":2,"title":"<code>batch_add_objects(objects)</code>","text":"<p>Add multiple objects to the model in a single call.</p> <p>Critical for efficiency — creating a building zone-by-zone requires many objects. Each entry should have: object_type (required), name (optional), fields (optional). Continues on individual failures and reports per-object results.</p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>list[dict[str, Any]]</code> <p>List of dicts with keys: object_type, name, fields.</p> required Source code in <code>src/idfkit_mcp/tools/write.py</code> <pre><code>@_safe_tool\ndef batch_add_objects(objects: list[dict[str, Any]]) -&gt; dict[str, Any]:\n    \"\"\"Add multiple objects to the model in a single call.\n\n    Critical for efficiency — creating a building zone-by-zone requires many objects.\n    Each entry should have: object_type (required), name (optional), fields (optional).\n    Continues on individual failures and reports per-object results.\n\n    Args:\n        objects: List of dicts with keys: object_type, name, fields.\n    \"\"\"\n    state = get_state()\n    doc = state.require_model()\n\n    results: list[dict[str, Any]] = []\n    success_count = 0\n    error_count = 0\n\n    for i, spec in enumerate(objects):\n        try:\n            obj_type = spec.get(\"object_type\")\n            if not obj_type:\n                results.append({\"index\": i, \"error\": \"Missing 'object_type'\"})\n                error_count += 1\n                continue\n\n            obj_name: str = spec.get(\"name\", \"\")\n            obj_fields: dict[str, Any] = spec.get(\"fields\") or {}\n            obj = doc.add(obj_type, obj_name, **obj_fields)\n            results.append({\"index\": i, **serialize_object(obj, brief=True)})\n            success_count += 1\n        except Exception as e:\n            results.append({\"index\": i, \"error\": str(e)})\n            error_count += 1\n\n    return {\"total\": len(objects), \"success\": success_count, \"errors\": error_count, \"results\": results}\n</code></pre>","path":["API Reference","Tools","Tools: Write"],"tags":[]},{"location":"api/tools-write/#idfkit_mcp.tools.write.duplicate_object","level":2,"title":"<code>duplicate_object(object_type, name, new_name)</code>","text":"<p>Duplicate an existing object with a new name.</p> <p>Parameters:</p> Name Type Description Default <code>object_type</code> <code>str</code> <p>The EnergyPlus object type.</p> required <code>name</code> <code>str</code> <p>The source object name.</p> required <code>new_name</code> <code>str</code> <p>The name for the duplicate.</p> required Source code in <code>src/idfkit_mcp/tools/write.py</code> <pre><code>@_safe_tool\ndef duplicate_object(object_type: str, name: str, new_name: str) -&gt; dict[str, Any]:\n    \"\"\"Duplicate an existing object with a new name.\n\n    Args:\n        object_type: The EnergyPlus object type.\n        name: The source object name.\n        new_name: The name for the duplicate.\n    \"\"\"\n    state = get_state()\n    doc = state.require_model()\n\n    obj = doc.copyidfobject(doc[object_type][name], new_name=new_name)\n    return serialize_object(obj)\n</code></pre>","path":["API Reference","Tools","Tools: Write"],"tags":[]},{"location":"api/tools-write/#idfkit_mcp.tools.write.new_model","level":2,"title":"<code>new_model(version=None)</code>","text":"<p>Create a new empty EnergyPlus model.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str | None</code> <p>EnergyPlus version as \"X.Y.Z\" (default: latest).</p> <code>None</code> Source code in <code>src/idfkit_mcp/tools/write.py</code> <pre><code>@_safe_tool\ndef new_model(version: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Create a new empty EnergyPlus model.\n\n    Args:\n        version: EnergyPlus version as \"X.Y.Z\" (default: latest).\n    \"\"\"\n    from idfkit import LATEST_VERSION, new_document, version_string\n\n    ver = LATEST_VERSION\n    if version is not None:\n        parts = version.split(\".\")\n        ver = (int(parts[0]), int(parts[1]), int(parts[2]))\n\n    doc = new_document(version=ver)\n    state = get_state()\n    state.document = doc\n    state.schema = doc.schema\n    state.file_path = None\n    state.simulation_result = None\n\n    return {\"status\": \"created\", \"version\": version_string(ver)}\n</code></pre>","path":["API Reference","Tools","Tools: Write"],"tags":[]},{"location":"api/tools-write/#idfkit_mcp.tools.write.register","level":2,"title":"<code>register(mcp)</code>","text":"<p>Register write tools on the MCP server.</p> Source code in <code>src/idfkit_mcp/tools/write.py</code> <pre><code>def register(mcp: FastMCP) -&gt; None:\n    \"\"\"Register write tools on the MCP server.\"\"\"\n    mcp.tool()(new_model)\n    mcp.tool()(add_object)\n    mcp.tool()(batch_add_objects)\n    mcp.tool()(update_object)\n    mcp.tool()(remove_object)\n    mcp.tool()(rename_object)\n    mcp.tool()(duplicate_object)\n    mcp.tool()(save_model)\n</code></pre>","path":["API Reference","Tools","Tools: Write"],"tags":[]},{"location":"api/tools-write/#idfkit_mcp.tools.write.remove_object","level":2,"title":"<code>remove_object(object_type, name, force=False)</code>","text":"<p>Remove an object from the model.</p> <p>By default, refuses removal if other objects reference this one. Use force=True to remove anyway.</p> <p>Parameters:</p> Name Type Description Default <code>object_type</code> <code>str</code> <p>The EnergyPlus object type.</p> required <code>name</code> <code>str</code> <p>The object name.</p> required <code>force</code> <code>bool</code> <p>If True, remove even if referenced by other objects.</p> <code>False</code> Source code in <code>src/idfkit_mcp/tools/write.py</code> <pre><code>@_safe_tool\ndef remove_object(object_type: str, name: str, force: bool = False) -&gt; dict[str, Any]:\n    \"\"\"Remove an object from the model.\n\n    By default, refuses removal if other objects reference this one.\n    Use force=True to remove anyway.\n\n    Args:\n        object_type: The EnergyPlus object type.\n        name: The object name.\n        force: If True, remove even if referenced by other objects.\n    \"\"\"\n    state = get_state()\n    doc = state.require_model()\n\n    if object_type not in doc:\n        return {\"error\": f\"No objects of type '{object_type}' in the model.\"}\n\n    obj = doc[object_type].get(name)\n    if obj is None:\n        return {\"error\": f\"Object '{name}' not found in '{object_type}'.\"}\n\n    if not force:\n        referencing = doc.get_referencing(name)\n        if referencing:\n            refs = [{\"object_type\": r.obj_type, \"name\": r.name} for r in referencing]\n            return {\n                \"error\": \"Object is referenced by other objects. Use force=True to remove anyway.\",\n                \"referenced_by\": refs,\n            }\n\n    doc.removeidfobject(obj)\n    return {\"status\": \"removed\", \"object_type\": object_type, \"name\": name}\n</code></pre>","path":["API Reference","Tools","Tools: Write"],"tags":[]},{"location":"api/tools-write/#idfkit_mcp.tools.write.rename_object","level":2,"title":"<code>rename_object(object_type, old_name, new_name)</code>","text":"<p>Rename an object and update all references to it.</p> <p>Parameters:</p> Name Type Description Default <code>object_type</code> <code>str</code> <p>The EnergyPlus object type.</p> required <code>old_name</code> <code>str</code> <p>Current object name.</p> required <code>new_name</code> <code>str</code> <p>New object name.</p> required Source code in <code>src/idfkit_mcp/tools/write.py</code> <pre><code>@_safe_tool\ndef rename_object(object_type: str, old_name: str, new_name: str) -&gt; dict[str, Any]:\n    \"\"\"Rename an object and update all references to it.\n\n    Args:\n        object_type: The EnergyPlus object type.\n        old_name: Current object name.\n        new_name: New object name.\n    \"\"\"\n    state = get_state()\n    doc = state.require_model()\n\n    referencing_before = doc.get_referencing(old_name)\n    ref_count = len(referencing_before)\n\n    doc.rename(object_type, old_name, new_name)\n\n    return {\n        \"status\": \"renamed\",\n        \"object_type\": object_type,\n        \"old_name\": old_name,\n        \"new_name\": new_name,\n        \"references_updated\": ref_count,\n    }\n</code></pre>","path":["API Reference","Tools","Tools: Write"],"tags":[]},{"location":"api/tools-write/#idfkit_mcp.tools.write.save_model","level":2,"title":"<code>save_model(file_path=None, output_format='idf')</code>","text":"<p>Save the model to a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str | None</code> <p>Output path. If None, uses the original load path.</p> <code>None</code> <code>output_format</code> <code>str</code> <p>Output format: \"idf\" or \"epjson\".</p> <code>'idf'</code> Source code in <code>src/idfkit_mcp/tools/write.py</code> <pre><code>@_safe_tool\ndef save_model(file_path: str | None = None, output_format: str = \"idf\") -&gt; dict[str, Any]:\n    \"\"\"Save the model to a file.\n\n    Args:\n        file_path: Output path. If None, uses the original load path.\n        output_format: Output format: \"idf\" or \"epjson\".\n    \"\"\"\n    from pathlib import Path\n\n    from idfkit import write_epjson, write_idf\n\n    state = get_state()\n    doc = state.require_model()\n\n    if file_path is not None:\n        path = Path(file_path)\n    elif state.file_path is not None:\n        path = state.file_path\n    else:\n        return {\"error\": \"No file path specified and no original path available.\"}\n\n    if output_format.lower() == \"epjson\":\n        write_epjson(doc, path)\n    else:\n        write_idf(doc, path)\n\n    state.file_path = path\n    return {\"status\": \"saved\", \"file_path\": str(path), \"format\": output_format}\n</code></pre>","path":["API Reference","Tools","Tools: Write"],"tags":[]},{"location":"api/tools-write/#idfkit_mcp.tools.write.update_object","level":2,"title":"<code>update_object(object_type, name, fields)</code>","text":"<p>Update fields on an existing object.</p> <p>Parameters:</p> Name Type Description Default <code>object_type</code> <code>str</code> <p>The EnergyPlus object type.</p> required <code>name</code> <code>str</code> <p>The object name.</p> required <code>fields</code> <code>dict[str, Any]</code> <p>Fields to update as {field_name: value}.</p> required Source code in <code>src/idfkit_mcp/tools/write.py</code> <pre><code>@_safe_tool\ndef update_object(object_type: str, name: str, fields: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Update fields on an existing object.\n\n    Args:\n        object_type: The EnergyPlus object type.\n        name: The object name.\n        fields: Fields to update as {field_name: value}.\n    \"\"\"\n    state = get_state()\n    doc = state.require_model()\n\n    if object_type not in doc:\n        return {\"error\": f\"No objects of type '{object_type}' in the model.\"}\n\n    obj = doc[object_type].get(name)\n    if obj is None:\n        return {\"error\": f\"Object '{name}' not found in '{object_type}'.\"}\n\n    for field_name, value in fields.items():\n        setattr(obj, field_name, value)\n\n    return serialize_object(obj)\n</code></pre>","path":["API Reference","Tools","Tools: Write"],"tags":[]},{"location":"concepts/error-semantics/","level":1,"title":"Error Semantics","text":"<p>Tools return structured dictionaries for both success and failure paths.</p>","path":["Concepts","Error Semantics"],"tags":[]},{"location":"concepts/error-semantics/#error-shape","level":2,"title":"Error Shape","text":"<p>Typical failure response:</p> <pre><code>{\n  \"error\": \"...\",\n  \"details\": \"...\"\n}\n</code></pre> <p>Some errors include targeted hints, for example EnergyPlus discovery failures include a <code>suggestion</code> field.</p>","path":["Concepts","Error Semantics"],"tags":[]},{"location":"concepts/error-semantics/#typed-error-mapping","level":2,"title":"Typed Error Mapping","text":"<p>The server normalizes common exceptions from <code>idfkit</code>:</p> <ul> <li>validation failures</li> <li>unknown object types</li> <li>duplicate object names</li> <li>missing schema/version</li> <li>simulation failures</li> <li>missing EnergyPlus installation</li> </ul> <p>This allows clients and agents to build deterministic remediation branches.</p>","path":["Concepts","Error Semantics"],"tags":[]},{"location":"concepts/error-semantics/#safe-agent-handling-pattern","level":2,"title":"Safe Agent Handling Pattern","text":"<ol> <li>Check for <code>error</code> key on every tool response.</li> <li>If present, halt dependent calls.</li> <li>Apply the smallest argument change needed.</li> <li>Retry that call.</li> <li>Re-run validation gates after recovery edits.</li> </ol>","path":["Concepts","Error Semantics"],"tags":[]},{"location":"concepts/error-semantics/#why-this-matters","level":2,"title":"Why This Matters","text":"<p>Without explicit error branching, autonomous workflows tend to drift into invalid model states and compound failures.</p>","path":["Concepts","Error Semantics"],"tags":[]},{"location":"concepts/server-state/","level":1,"title":"Server State","text":"<p><code>idfkit-mcp</code> keeps an in-memory state object across tool calls in a session.</p>","path":["Concepts","Server State"],"tags":[]},{"location":"concepts/server-state/#state-fields","level":2,"title":"State Fields","text":"<ul> <li><code>document</code>: active EnergyPlus model</li> <li><code>schema</code>: active schema (usually from model)</li> <li><code>file_path</code>: current model path</li> <li><code>simulation_result</code>: last run result</li> <li><code>weather_file</code>: last downloaded EPW path</li> </ul>","path":["Concepts","Server State"],"tags":[]},{"location":"concepts/server-state/#implications-for-agent-design","level":2,"title":"Implications for Agent Design","text":"<ul> <li>Calls are stateful, not stateless RPC.</li> <li>Sequence matters.</li> <li>Loading a new model replaces prior context.</li> <li>Simulation and weather data are session-local.</li> </ul>","path":["Concepts","Server State"],"tags":[]},{"location":"concepts/server-state/#required-preconditions","level":2,"title":"Required Preconditions","text":"<p>Some tools require prior state:</p> <ul> <li>model required: most read/write/validation/simulation tools</li> <li>simulation result required: <code>get_results_summary</code>, <code>list_output_variables</code></li> </ul> <p>If missing, tools return descriptive errors such as:</p> <ul> <li><code>No model loaded. Use load_model or new_model first.</code></li> <li><code>No simulation results available. Use run_simulation first.</code></li> </ul>","path":["Concepts","Server State"],"tags":[]},{"location":"concepts/server-state/#session-strategy","level":2,"title":"Session Strategy","text":"<p>For deterministic automation:</p> <ol> <li>start with explicit <code>load_model</code> or <code>new_model</code></li> <li>complete one workflow at a time</li> <li>persist artifacts with <code>save_model</code></li> </ol>","path":["Concepts","Server State"],"tags":[]},{"location":"getting-started/client-setup/","level":1,"title":"MCP Client Setup","text":"<p>This page shows practical server configurations for common MCP clients.</p>","path":["Get Started","MCP Client Setup"],"tags":[]},{"location":"getting-started/client-setup/#common-command","level":2,"title":"Common Command","text":"<p>All clients ultimately need to run:</p> <pre><code>idfkit-mcp\n</code></pre> <p>or</p> <pre><code>uvx --from idfkit-mcp idfkit-mcp\n</code></pre> <p>Use <code>uvx</code> when you want a managed, versioned runtime without installing into a project environment.</p>","path":["Get Started","MCP Client Setup"],"tags":[]},{"location":"getting-started/client-setup/#transport-options","level":2,"title":"Transport Options","text":"<ul> <li>Local desktop clients (Codex, Claude Desktop, Cursor, VS Code MCP): use <code>stdio</code> (default).</li> <li>Hosted deployments: use <code>streamable-http</code> and expose a reachable host/port.</li> </ul>","path":["Get Started","MCP Client Setup"],"tags":[]},{"location":"getting-started/client-setup/#codex","level":2,"title":"Codex","text":"<p>In Codex, add a new MCP server pointing to <code>idfkit-mcp</code> (or the <code>uvx</code> wrapper command).</p> <p>Recommended command:</p> <pre><code>uvx --from idfkit-mcp idfkit-mcp\n</code></pre> <p>Recommended working directory:</p> <ul> <li>The repository where IDF/epJSON files and simulation outputs should live.</li> </ul> <p>Recommended prompt behavior:</p> <ul> <li>Start sessions with <code>get_model_summary</code>.</li> <li>Call <code>describe_object_type</code> before object creation or updates.</li> <li>Validate after every edit batch.</li> </ul>","path":["Get Started","MCP Client Setup"],"tags":[]},{"location":"getting-started/client-setup/#claude-desktop","level":2,"title":"Claude Desktop","text":"<p>Add an <code>idfkit</code> server entry to Claude Desktop MCP config.</p> <p>macOS config file:</p> <pre><code>~/Library/Application Support/Claude/claude_desktop_config.json\n</code></pre> <p>Example:</p> <pre><code>{\n  \"mcpServers\": {\n    \"idfkit\": {\n      \"command\": \"uvx\",\n      \"args\": [\"--from\", \"idfkit-mcp\", \"idfkit-mcp\"]\n    }\n  }\n}\n</code></pre> <p>Restart Claude Desktop after saving.</p>","path":["Get Started","MCP Client Setup"],"tags":[]},{"location":"getting-started/client-setup/#cursor","level":2,"title":"Cursor","text":"<p>Cursor MCP config file:</p> <pre><code>~/.cursor/mcp.json\n</code></pre> <p>Example:</p> <pre><code>{\n  \"mcpServers\": {\n    \"idfkit\": {\n      \"command\": \"uvx\",\n      \"args\": [\"--from\", \"idfkit-mcp\", \"idfkit-mcp\"]\n    }\n  }\n}\n</code></pre>","path":["Get Started","MCP Client Setup"],"tags":[]},{"location":"getting-started/client-setup/#vs-code","level":2,"title":"VS Code","text":"<p>Workspace settings example:</p> <pre><code>{\n  \"mcp.servers\": {\n    \"idfkit\": {\n      \"command\": \"uvx\",\n      \"args\": [\"--from\", \"idfkit-mcp\", \"idfkit-mcp\"]\n    }\n  }\n}\n</code></pre>","path":["Get Started","MCP Client Setup"],"tags":[]},{"location":"getting-started/client-setup/#operational-tips","level":2,"title":"Operational Tips","text":"<ul> <li>Prefer absolute paths when loading or saving models.</li> <li>Keep one modeling task per server session to avoid state confusion.</li> <li>Use <code>batch_add_objects</code> when agents need to create many objects.</li> <li>Capture outputs in files if your client truncates long tool responses.</li> </ul>","path":["Get Started","MCP Client Setup"],"tags":[]},{"location":"getting-started/first-session/","level":1,"title":"First Session","text":"<p>This walkthrough demonstrates a complete first run in any MCP client.</p>","path":["Get Started","First Session"],"tags":[]},{"location":"getting-started/first-session/#goal","level":2,"title":"Goal","text":"<p>Create a model, add zones, validate, save, reload, and inspect.</p>","path":["Get Started","First Session"],"tags":[]},{"location":"getting-started/first-session/#step-by-step-calls","level":2,"title":"Step-by-Step Calls","text":"","path":["Get Started","First Session"],"tags":[]},{"location":"getting-started/first-session/#1-create-a-new-model","level":3,"title":"1. Create a New Model","text":"<pre><code>{\n  \"tool\": \"new_model\",\n  \"arguments\": {\n    \"version\": \"24.1.0\"\n  }\n}\n</code></pre>","path":["Get Started","First Session"],"tags":[]},{"location":"getting-started/first-session/#2-inspect-schema-before-writing","level":3,"title":"2. Inspect Schema Before Writing","text":"<pre><code>{\n  \"tool\": \"describe_object_type\",\n  \"arguments\": {\n    \"object_type\": \"Zone\"\n  }\n}\n</code></pre>","path":["Get Started","First Session"],"tags":[]},{"location":"getting-started/first-session/#3-add-multiple-objects-efficiently","level":3,"title":"3. Add Multiple Objects Efficiently","text":"<pre><code>{\n  \"tool\": \"batch_add_objects\",\n  \"arguments\": {\n    \"objects\": [\n      {\"object_type\": \"Zone\", \"name\": \"Office\"},\n      {\"object_type\": \"Zone\", \"name\": \"Corridor\"},\n      {\"object_type\": \"Zone\", \"name\": \"Storage\"}\n    ]\n  }\n}\n</code></pre>","path":["Get Started","First Session"],"tags":[]},{"location":"getting-started/first-session/#4-validate","level":3,"title":"4. Validate","text":"<pre><code>{\n  \"tool\": \"validate_model\",\n  \"arguments\": {\n    \"check_references\": true\n  }\n}\n</code></pre>","path":["Get Started","First Session"],"tags":[]},{"location":"getting-started/first-session/#5-save","level":3,"title":"5. Save","text":"<pre><code>{\n  \"tool\": \"save_model\",\n  \"arguments\": {\n    \"file_path\": \"./example.idf\",\n    \"output_format\": \"idf\"\n  }\n}\n</code></pre>","path":["Get Started","First Session"],"tags":[]},{"location":"getting-started/first-session/#6-reload-and-verify","level":3,"title":"6. Reload and Verify","text":"<pre><code>{\n  \"tool\": \"load_model\",\n  \"arguments\": {\n    \"file_path\": \"./example.idf\"\n  }\n}\n</code></pre> <pre><code>{\n  \"tool\": \"get_model_summary\",\n  \"arguments\": {}\n}\n</code></pre>","path":["Get Started","First Session"],"tags":[]},{"location":"getting-started/first-session/#expected-outcome","level":2,"title":"Expected Outcome","text":"<ul> <li><code>zone_count</code> is <code>3</code></li> <li><code>total_objects</code> includes your new zones</li> <li>validation returns <code>is_valid: true</code></li> </ul>","path":["Get Started","First Session"],"tags":[]},{"location":"getting-started/first-session/#next-step-add-simulation","level":2,"title":"Next Step: Add Simulation","text":"<ol> <li><code>download_weather_file(query=\"Chicago\")</code></li> <li><code>run_simulation(annual=true)</code></li> <li><code>get_results_summary()</code></li> </ol>","path":["Get Started","First Session"],"tags":[]},{"location":"getting-started/installation/","level":1,"title":"Installation","text":"<p><code>idfkit-mcp</code> is distributed on PyPI and supports <code>stdio</code> and Streamable HTTP transports.</p>","path":["Get Started","Installation"],"tags":[]},{"location":"getting-started/installation/#install-the-package","level":2,"title":"Install the Package","text":"pipuv <pre><code>pip install idfkit-mcp\n</code></pre> <pre><code>uv add idfkit-mcp\n</code></pre>","path":["Get Started","Installation"],"tags":[]},{"location":"getting-started/installation/#runtime-requirements","level":2,"title":"Runtime Requirements","text":"<ul> <li>Python <code>3.10+</code></li> <li>EnergyPlus installed and discoverable (required for simulation tools)</li> <li>Network access for weather station downloads (when using weather tools)</li> </ul>","path":["Get Started","Installation"],"tags":[]},{"location":"getting-started/installation/#docker-images","level":2,"title":"Docker Images","text":"<p>This repo provides two Docker build targets:</p> <ul> <li><code>runtime</code>: Small HTTP server image without EnergyPlus (<code>run_simulation</code> unavailable)</li> <li><code>sim</code>: Includes EnergyPlus for full simulation support</li> </ul>","path":["Get Started","Installation"],"tags":[]},{"location":"getting-started/installation/#build-base-image","level":3,"title":"Build Base Image","text":"<pre><code>docker build --target runtime -t idfkit-mcp:latest .\n</code></pre>","path":["Get Started","Installation"],"tags":[]},{"location":"getting-started/installation/#build-simulation-image","level":3,"title":"Build Simulation Image","text":"<pre><code>docker build \\\n  --target sim \\\n  --build-arg ENERGYPLUS_TARBALL_URL=&lt;energyplus-linux-tarball-url&gt; \\\n  -t idfkit-mcp:sim .\n</code></pre> <p>Optional integrity verification:</p> <pre><code>docker build \\\n  --target sim \\\n  --build-arg ENERGYPLUS_TARBALL_URL=&lt;energyplus-linux-tarball-url&gt; \\\n  --build-arg ENERGYPLUS_TARBALL_SHA256=&lt;sha256&gt; \\\n  -t idfkit-mcp:sim .\n</code></pre> <p>Architecture note:</p> <ul> <li>The tarball architecture must match the image architecture.</li> <li>On Apple Silicon, most official EnergyPlus Linux tarballs are <code>x86_64</code>; build with <code>--platform linux/amd64</code> when using those assets or use the <code>arm64</code> tarball if available.</li> </ul>","path":["Get Started","Installation"],"tags":[]},{"location":"getting-started/installation/#build-with-make-targets","level":3,"title":"Build with Make Targets","text":"<pre><code>make docker-build\nmake docker-build-sim ENERGYPLUS_TARBALL_URL=&lt;energyplus-linux-tarball-url&gt;\nmake docker-build-sim DOCKER_PLATFORM=linux/amd64 ENERGYPLUS_TARBALL_URL=&lt;energyplus-linux-x86_64-tarball-url&gt;\n</code></pre>","path":["Get Started","Installation"],"tags":[]},{"location":"getting-started/installation/#launch-the-server","level":2,"title":"Launch the Server","text":"Installed scriptModuleWithout local install <pre><code>idfkit-mcp\n</code></pre> <pre><code>python -m idfkit_mcp.server\n</code></pre> <pre><code>uvx --from idfkit-mcp idfkit-mcp\n</code></pre>","path":["Get Started","Installation"],"tags":[]},{"location":"getting-started/installation/#transport-selection","level":2,"title":"Transport Selection","text":"<p><code>idfkit-mcp</code> can run either local stdio or network HTTP transport from the same codebase.</p>","path":["Get Started","Installation"],"tags":[]},{"location":"getting-started/installation/#stdio-default","level":3,"title":"stdio (default)","text":"<pre><code>idfkit-mcp --transport stdio\n</code></pre>","path":["Get Started","Installation"],"tags":[]},{"location":"getting-started/installation/#streamable-http","level":3,"title":"Streamable HTTP","text":"<pre><code>idfkit-mcp --transport streamable-http --host 127.0.0.1 --port 8000\n</code></pre>","path":["Get Started","Installation"],"tags":[]},{"location":"getting-started/installation/#environment-variable-configuration","level":3,"title":"Environment Variable Configuration","text":"<pre><code>IDFKIT_MCP_TRANSPORT=streamable-http IDFKIT_MCP_HOST=0.0.0.0 IDFKIT_MCP_PORT=8000 idfkit-mcp\n</code></pre>","path":["Get Started","Installation"],"tags":[]},{"location":"getting-started/installation/#energyplus-discovery","level":2,"title":"EnergyPlus Discovery","text":"<p>Simulation tools rely on <code>idfkit</code>'s EnergyPlus discovery chain:</p> <ol> <li>Explicit path passed by calling code</li> <li><code>ENERGYPLUS_DIR</code> environment variable</li> <li><code>energyplus</code> executable on <code>PATH</code></li> <li>Standard install locations by OS</li> </ol> <p>If simulation fails with an EnergyPlus discovery error, see Setup &amp; Configuration.</p>","path":["Get Started","Installation"],"tags":[]},{"location":"getting-started/installation/#verify-installation-quickly","level":2,"title":"Verify Installation Quickly","text":"<p>Use an MCP client and call:</p> <ol> <li><code>list_object_types()</code></li> <li><code>new_model()</code></li> <li><code>get_model_summary()</code></li> </ol> <p>If all three succeed, your server is healthy.</p>","path":["Get Started","Installation"],"tags":[]},{"location":"getting-started/installation/#next-steps","level":2,"title":"Next Steps","text":"<ul> <li>MCP Client Setup</li> <li>First Session</li> </ul>","path":["Get Started","Installation"],"tags":[]},{"location":"tools/","level":1,"title":"Tool Reference Overview","text":"<p><code>idfkit-mcp</code> exposes 25 tools in six categories.</p>","path":["Tool Reference","Tool Reference Overview"],"tags":[]},{"location":"tools/#categories","level":2,"title":"Categories","text":"<ul> <li>Schema exploration: 4 tools</li> <li>Model read: 6 tools</li> <li>Model write: 8 tools</li> <li>Validation: 2 tools</li> <li>Simulation: 3 tools</li> <li>Weather: 2 tools</li> </ul>","path":["Tool Reference","Tool Reference Overview"],"tags":[]},{"location":"tools/#tool-catalog","level":2,"title":"Tool Catalog","text":"Category Tool Purpose Schema <code>list_object_types</code> List available EnergyPlus object types Schema <code>describe_object_type</code> Get full field contract for one type Schema <code>search_schema</code> Search object types by name/memo Schema <code>get_available_references</code> Resolve valid reference values from model Read <code>load_model</code> Load IDF/epJSON into active server state Read <code>get_model_summary</code> Summarize loaded model Read <code>list_objects</code> List objects by type Read <code>get_object</code> Fetch one object by type/name Read <code>search_objects</code> Search model objects by substring Read <code>get_references</code> Inspect inbound and outbound references Write <code>new_model</code> Create empty model Write <code>add_object</code> Add one object Write <code>batch_add_objects</code> Add many objects in one call Write <code>update_object</code> Update fields on one object Write <code>remove_object</code> Remove object, optionally forced Write <code>rename_object</code> Rename object and cascade references Write <code>duplicate_object</code> Clone object to a new name Write <code>save_model</code> Save IDF/epJSON Validation <code>validate_model</code> Full schema validation Validation <code>check_references</code> Detect dangling references Simulation <code>run_simulation</code> Execute EnergyPlus run Simulation <code>get_results_summary</code> Summarize previous run Simulation <code>list_output_variables</code> Enumerate meters/variables Weather <code>search_weather_stations</code> Find weather stations Weather <code>download_weather_file</code> Download EPW/DDY and cache path","path":["Tool Reference","Tool Reference Overview"],"tags":[]},{"location":"tools/#global-best-practices","level":2,"title":"Global Best Practices","text":"<ol> <li>Use schema tools before mutations.</li> <li>Prefer batched writes.</li> <li>Validate immediately after writes.</li> <li>Run simulation only after model health checks pass.</li> <li>Treat each server session as stateful and sequential.</li> </ol>","path":["Tool Reference","Tool Reference Overview"],"tags":[]},{"location":"tools/model-read/","level":1,"title":"Model Read Tools","text":"<p>Read tools expose current model content and relationships.</p>","path":["Tool Reference","Model Read Tools"],"tags":[]},{"location":"tools/model-read/#load_model","level":2,"title":"<code>load_model</code>","text":"<p>Loads IDF or epJSON into active server state.</p> <p>Notes:</p> <ul> <li>File type inferred from extension.</li> <li>Optional <code>version</code> override (<code>X.Y.Z</code>) is supported.</li> <li>Loading resets previous simulation result state.</li> </ul>","path":["Tool Reference","Model Read Tools"],"tags":[]},{"location":"tools/model-read/#get_model_summary","level":2,"title":"<code>get_model_summary</code>","text":"<p>Returns:</p> <ul> <li>version</li> <li>file path</li> <li>object totals</li> <li>zone count</li> <li>grouped type counts</li> </ul> <p>Use this as your first inspection call.</p>","path":["Tool Reference","Model Read Tools"],"tags":[]},{"location":"tools/model-read/#list_objects","level":2,"title":"<code>list_objects</code>","text":"<p>Returns brief serialized objects for one <code>object_type</code>.</p> <p>Parameters:</p> <ul> <li><code>object_type</code> (required)</li> <li><code>limit</code> (default <code>50</code>)</li> </ul>","path":["Tool Reference","Model Read Tools"],"tags":[]},{"location":"tools/model-read/#get_object","level":2,"title":"<code>get_object</code>","text":"<p>Fetches a specific object by type and name.</p>","path":["Tool Reference","Model Read Tools"],"tags":[]},{"location":"tools/model-read/#search_objects","level":2,"title":"<code>search_objects</code>","text":"<p>Case-insensitive substring search across names and string fields.</p> <p>Optional <code>object_type</code> filter narrows results.</p>","path":["Tool Reference","Model Read Tools"],"tags":[]},{"location":"tools/model-read/#get_references","level":2,"title":"<code>get_references</code>","text":"<p>Returns both:</p> <ul> <li>objects that reference the target name</li> <li>names referenced by the target object</li> </ul> <p>Use this before renaming or removing high-connectivity objects.</p>","path":["Tool Reference","Model Read Tools"],"tags":[]},{"location":"tools/model-write/","level":1,"title":"Model Write Tools","text":"<p>Write tools mutate the active model.</p>","path":["Tool Reference","Model Write Tools"],"tags":[]},{"location":"tools/model-write/#new_model","level":2,"title":"<code>new_model</code>","text":"<p>Creates a new empty model, optionally pinned to an EnergyPlus version.</p>","path":["Tool Reference","Model Write Tools"],"tags":[]},{"location":"tools/model-write/#add_object","level":2,"title":"<code>add_object</code>","text":"<p>Adds one object.</p> <p>Recommended workflow:</p> <ol> <li><code>describe_object_type</code></li> <li><code>add_object</code></li> <li><code>validate_model</code></li> </ol>","path":["Tool Reference","Model Write Tools"],"tags":[]},{"location":"tools/model-write/#batch_add_objects","level":2,"title":"<code>batch_add_objects</code>","text":"<p>Adds many objects in one round-trip.</p> <p>Why it matters:</p> <ul> <li>lower client/server latency</li> <li>easier atomic planning for agents</li> <li>per-item error reporting without aborting the whole batch</li> </ul>","path":["Tool Reference","Model Write Tools"],"tags":[]},{"location":"tools/model-write/#update_object","level":2,"title":"<code>update_object</code>","text":"<p>Updates specific fields on an existing object.</p> <p>Tip: only send changed fields to keep edits auditable.</p>","path":["Tool Reference","Model Write Tools"],"tags":[]},{"location":"tools/model-write/#remove_object","level":2,"title":"<code>remove_object</code>","text":"<p>By default, guarded against deleting referenced objects.</p> <ul> <li>without <code>force</code>: returns <code>referenced_by</code> details when blocked</li> <li>with <code>force=true</code>: removes anyway</li> </ul>","path":["Tool Reference","Model Write Tools"],"tags":[]},{"location":"tools/model-write/#rename_object","level":2,"title":"<code>rename_object</code>","text":"<p>Renames an object and cascades reference updates.</p>","path":["Tool Reference","Model Write Tools"],"tags":[]},{"location":"tools/model-write/#duplicate_object","level":2,"title":"<code>duplicate_object</code>","text":"<p>Clones an existing object under <code>new_name</code>.</p>","path":["Tool Reference","Model Write Tools"],"tags":[]},{"location":"tools/model-write/#save_model","level":2,"title":"<code>save_model</code>","text":"<p>Writes current model to disk as:</p> <ul> <li><code>idf</code> (default)</li> <li><code>epjson</code></li> </ul> <p>If <code>file_path</code> is omitted, uses the original loaded path when available.</p>","path":["Tool Reference","Model Write Tools"],"tags":[]},{"location":"tools/schema/","level":1,"title":"Schema Tools","text":"<p>Schema tools let agents reason about object structure before editing models.</p>","path":["Tool Reference","Schema Tools"],"tags":[]},{"location":"tools/schema/#list_object_types","level":2,"title":"<code>list_object_types</code>","text":"<p>List available object types, optionally filtered by group and version.</p> <p>Use cases:</p> <ul> <li>discover object families</li> <li>constrain planning space for autonomous agents</li> </ul>","path":["Tool Reference","Schema Tools"],"tags":[]},{"location":"tools/schema/#describe_object_type","level":2,"title":"<code>describe_object_type</code>","text":"<p>Returns detailed field metadata:</p> <ul> <li>required fields</li> <li>defaults</li> <li>enums</li> <li>min/max constraints</li> <li>reference lists</li> </ul> <p>Use this before any <code>add_object</code> or <code>update_object</code> call.</p>","path":["Tool Reference","Schema Tools"],"tags":[]},{"location":"tools/schema/#search_schema","level":2,"title":"<code>search_schema</code>","text":"<p>Find types by name or schema memo text.</p> <p>Useful when the agent only has conceptual intent, such as \"infiltration\" or \"internal gains\".</p>","path":["Tool Reference","Schema Tools"],"tags":[]},{"location":"tools/schema/#get_available_references","level":2,"title":"<code>get_available_references</code>","text":"<p>Given an object type and reference field, returns valid names from current model state.</p> <p>Typical usage:</p> <ol> <li><code>describe_object_type(\"BuildingSurface:Detailed\")</code></li> <li><code>get_available_references(object_type=\"BuildingSurface:Detailed\", field_name=\"zone_name\")</code></li> <li>choose value from <code>available_names</code></li> </ol>","path":["Tool Reference","Schema Tools"],"tags":[]},{"location":"tools/schema/#schema-first-editing-pattern","level":2,"title":"Schema-First Editing Pattern","text":"<pre><code>describe_object_type -&gt; add/update -&gt; validate_model\n</code></pre>","path":["Tool Reference","Schema Tools"],"tags":[]},{"location":"tools/simulation/","level":1,"title":"Simulation Tools","text":"<p>Simulation tools execute EnergyPlus and expose summarized outputs.</p>","path":["Tool Reference","Simulation Tools"],"tags":[]},{"location":"tools/simulation/#run_simulation","level":2,"title":"<code>run_simulation</code>","text":"<p>Parameters:</p> <ul> <li><code>weather_file</code>: explicit EPW path (optional if weather already downloaded)</li> <li><code>design_day</code>: design-day-only run</li> <li><code>annual</code>: annual run</li> <li><code>energyplus_dir</code>: optional explicit EnergyPlus directory or executable path</li> <li><code>energyplus_version</code>: optional EnergyPlus version filter (for example <code>25.1.0</code>)</li> </ul> <p>Behavior:</p> <ul> <li>Uses server-cached weather path when available.</li> <li>Returns runtime, output directory, and error counts.</li> <li>Returns the resolved EnergyPlus executable, install directory, and version.</li> <li>Stores result in server state for follow-up tools.</li> </ul>","path":["Tool Reference","Simulation Tools"],"tags":[]},{"location":"tools/simulation/#get_results_summary","level":2,"title":"<code>get_results_summary</code>","text":"<p>Summarizes the latest simulation result:</p> <ul> <li>success flag</li> <li>runtime</li> <li>fatal/severe/warning counts</li> <li>severe/fatal messages</li> <li>first batch of HTML report tables when available</li> </ul>","path":["Tool Reference","Simulation Tools"],"tags":[]},{"location":"tools/simulation/#list_output_variables","level":2,"title":"<code>list_output_variables</code>","text":"<p>Lists available variables/meters from run output metadata.</p> <p>Parameters:</p> <ul> <li><code>search</code>: optional regex</li> <li><code>limit</code>: default <code>50</code></li> </ul>","path":["Tool Reference","Simulation Tools"],"tags":[]},{"location":"tools/simulation/#simulation-workflow","level":2,"title":"Simulation Workflow","text":"<ol> <li><code>download_weather_file</code> or provide <code>weather_file</code></li> <li><code>run_simulation</code></li> <li><code>get_results_summary</code></li> <li><code>list_output_variables(search=...)</code></li> </ol>","path":["Tool Reference","Simulation Tools"],"tags":[]},{"location":"tools/simulation/#common-guardrail","level":2,"title":"Common Guardrail","text":"<p>If <code>run_simulation</code> reports missing weather, either:</p> <ul> <li>call <code>download_weather_file</code>, or</li> <li>pass an explicit EPW path.</li> </ul>","path":["Tool Reference","Simulation Tools"],"tags":[]},{"location":"tools/validation/","level":1,"title":"Validation Tools","text":"<p>Validation is the core reliability gate for agentic model editing.</p>","path":["Tool Reference","Validation Tools"],"tags":[]},{"location":"tools/validation/#validate_model","level":2,"title":"<code>validate_model</code>","text":"<p>Runs schema validation with optional filters.</p> <p>Parameters:</p> <ul> <li><code>object_types</code>: validate only selected types</li> <li><code>check_references</code>: include reference integrity checks (default <code>true</code>)</li> </ul> <p>Response highlights:</p> <ul> <li><code>is_valid</code></li> <li>counts by severity</li> <li>structured error and warning entries</li> </ul>","path":["Tool Reference","Validation Tools"],"tags":[]},{"location":"tools/validation/#check_references","level":2,"title":"<code>check_references</code>","text":"<p>Performs explicit dangling-reference detection.</p> <p>Response:</p> <ul> <li><code>dangling_count</code></li> <li>list of source object, field, and missing target</li> </ul>","path":["Tool Reference","Validation Tools"],"tags":[]},{"location":"tools/validation/#recommended-gate","level":2,"title":"Recommended Gate","text":"<p>Run both tools after any mutation batch:</p> <ol> <li><code>validate_model(check_references=true)</code></li> <li><code>check_references()</code></li> </ol> <p>Only proceed to simulation when both are clean.</p>","path":["Tool Reference","Validation Tools"],"tags":[]},{"location":"tools/weather/","level":1,"title":"Weather Tools","text":"<p>Weather tools provide station discovery and EPW/DDY retrieval for simulation.</p>","path":["Tool Reference","Weather Tools"],"tags":[]},{"location":"tools/weather/#search_weather_stations","level":2,"title":"<code>search_weather_stations</code>","text":"<p>Two query modes:</p> <ul> <li>Text mode: <code>query=\"Chicago\"</code></li> <li>Spatial mode: <code>latitude=..., longitude=...</code></li> </ul> <p>Optional filters:</p> <ul> <li><code>country</code> (e.g., <code>USA</code>)</li> <li><code>limit</code></li> </ul> <p>Returns station metadata, plus:</p> <ul> <li>relevance score for text search</li> <li>distance for spatial search</li> </ul>","path":["Tool Reference","Weather Tools"],"tags":[]},{"location":"tools/weather/#download_weather_file","level":2,"title":"<code>download_weather_file</code>","text":"<p>Two selection modes:</p> <ul> <li>direct by <code>wmo</code></li> <li>best match by <code>query</code></li> </ul> <p>Downloads weather files and stores EPW path in server state for reuse by <code>run_simulation</code>.</p> <p>Response includes:</p> <ul> <li>station metadata</li> <li><code>epw_path</code></li> <li><code>ddy_path</code></li> </ul>","path":["Tool Reference","Weather Tools"],"tags":[]},{"location":"tools/weather/#typical-flow","level":2,"title":"Typical Flow","text":"<ol> <li><code>search_weather_stations(query=\"Boston\", country=\"USA\")</code></li> <li><code>download_weather_file(wmo=\"725090\")</code> or by query</li> <li><code>run_simulation()</code> without explicit weather path</li> </ol>","path":["Tool Reference","Weather Tools"],"tags":[]},{"location":"troubleshooting/setup/","level":1,"title":"Setup &amp; Configuration","text":"","path":["Troubleshooting","Setup &amp; Configuration"],"tags":[]},{"location":"troubleshooting/setup/#server-does-not-start","level":2,"title":"Server Does Not Start","text":"","path":["Troubleshooting","Setup &amp; Configuration"],"tags":[]},{"location":"troubleshooting/setup/#symptom","level":3,"title":"Symptom","text":"<p>Client reports command not found for <code>idfkit-mcp</code>.</p>","path":["Troubleshooting","Setup &amp; Configuration"],"tags":[]},{"location":"troubleshooting/setup/#fix","level":3,"title":"Fix","text":"<ul> <li>Install package in the runtime environment.</li> <li>Or switch to <code>uvx --from idfkit-mcp idfkit-mcp</code>.</li> </ul>","path":["Troubleshooting","Setup &amp; Configuration"],"tags":[]},{"location":"troubleshooting/setup/#mcp-client-cannot-connect","level":2,"title":"MCP Client Cannot Connect","text":"","path":["Troubleshooting","Setup &amp; Configuration"],"tags":[]},{"location":"troubleshooting/setup/#checks","level":3,"title":"Checks","text":"<ol> <li>Confirm JSON config is valid (no comments).</li> <li>Confirm command runs in terminal:    <pre><code>uvx --from idfkit-mcp idfkit-mcp\n</code></pre></li> <li>Restart client after config changes.</li> </ol>","path":["Troubleshooting","Setup &amp; Configuration"],"tags":[]},{"location":"troubleshooting/setup/#energyplus-not-found","level":2,"title":"<code>EnergyPlus not found</code>","text":"","path":["Troubleshooting","Setup &amp; Configuration"],"tags":[]},{"location":"troubleshooting/setup/#cause","level":3,"title":"Cause","text":"<p>Simulation tool cannot resolve EnergyPlus installation.</p>","path":["Troubleshooting","Setup &amp; Configuration"],"tags":[]},{"location":"troubleshooting/setup/#fix_1","level":3,"title":"Fix","text":"<ol> <li>Install EnergyPlus.</li> <li>Set <code>ENERGYPLUS_DIR</code>.</li> <li>Verify <code>energyplus</code> is on <code>PATH</code>.</li> </ol>","path":["Troubleshooting","Setup &amp; Configuration"],"tags":[]},{"location":"troubleshooting/setup/#no-model-loaded","level":2,"title":"<code>No model loaded</code>","text":"","path":["Troubleshooting","Setup &amp; Configuration"],"tags":[]},{"location":"troubleshooting/setup/#cause_1","level":3,"title":"Cause","text":"<p>Read/write/validation/simulation tool called before loading or creating a model.</p>","path":["Troubleshooting","Setup &amp; Configuration"],"tags":[]},{"location":"troubleshooting/setup/#fix_2","level":3,"title":"Fix","text":"<p>Call one of:</p> <ul> <li><code>load_model(file_path=...)</code></li> <li><code>new_model()</code></li> </ul>","path":["Troubleshooting","Setup &amp; Configuration"],"tags":[]},{"location":"troubleshooting/setup/#schema-version-errors","level":2,"title":"Schema Version Errors","text":"","path":["Troubleshooting","Setup &amp; Configuration"],"tags":[]},{"location":"troubleshooting/setup/#symptom_1","level":3,"title":"Symptom","text":"<p><code>Version must be in 'X.Y.Z' format</code> or schema not found.</p>","path":["Troubleshooting","Setup &amp; Configuration"],"tags":[]},{"location":"troubleshooting/setup/#fix_3","level":3,"title":"Fix","text":"<ul> <li>Use strict semantic format, e.g. <code>24.1.0</code>.</li> <li>Use a supported version provided by installed <code>idfkit</code>.</li> </ul>","path":["Troubleshooting","Setup &amp; Configuration"],"tags":[]},{"location":"troubleshooting/simulation/","level":1,"title":"Modeling &amp; Simulation Troubleshooting","text":"","path":["Troubleshooting","Modeling &amp; Simulation Troubleshooting"],"tags":[]},{"location":"troubleshooting/simulation/#missing-weather-file-error","level":2,"title":"Missing Weather File Error","text":"","path":["Troubleshooting","Modeling &amp; Simulation Troubleshooting"],"tags":[]},{"location":"troubleshooting/simulation/#symptom","level":3,"title":"Symptom","text":"<p><code>run_simulation</code> returns weather-related error.</p>","path":["Troubleshooting","Modeling &amp; Simulation Troubleshooting"],"tags":[]},{"location":"troubleshooting/simulation/#fix","level":3,"title":"Fix","text":"<ul> <li>Call <code>download_weather_file(query=...)</code> first, or</li> <li>pass explicit <code>weather_file</code> path.</li> </ul>","path":["Troubleshooting","Modeling &amp; Simulation Troubleshooting"],"tags":[]},{"location":"troubleshooting/simulation/#validation-fails-repeatedly","level":2,"title":"Validation Fails Repeatedly","text":"","path":["Troubleshooting","Modeling &amp; Simulation Troubleshooting"],"tags":[]},{"location":"troubleshooting/simulation/#strategy","level":3,"title":"Strategy","text":"<ol> <li>Run <code>validate_model(object_types=[...])</code> to narrow scope.</li> <li>Call <code>describe_object_type</code> for failing types.</li> <li>Repair fields using <code>update_object</code>.</li> <li>Re-run validation.</li> </ol>","path":["Troubleshooting","Modeling &amp; Simulation Troubleshooting"],"tags":[]},{"location":"troubleshooting/simulation/#dangling-references","level":2,"title":"Dangling References","text":"","path":["Troubleshooting","Modeling &amp; Simulation Troubleshooting"],"tags":[]},{"location":"troubleshooting/simulation/#symptom_1","level":3,"title":"Symptom","text":"<p><code>check_references</code> returns <code>dangling_count &gt; 0</code>.</p>","path":["Troubleshooting","Modeling &amp; Simulation Troubleshooting"],"tags":[]},{"location":"troubleshooting/simulation/#fix-pattern","level":3,"title":"Fix pattern","text":"<ol> <li>Inspect each entry's <code>source_type</code>, <code>field</code>, and <code>missing_target</code>.</li> <li>Use <code>get_available_references</code> for that field.</li> <li>Update to valid target names.</li> </ol>","path":["Troubleshooting","Modeling &amp; Simulation Troubleshooting"],"tags":[]},{"location":"troubleshooting/simulation/#object-removal-is-blocked","level":2,"title":"Object Removal Is Blocked","text":"","path":["Troubleshooting","Modeling &amp; Simulation Troubleshooting"],"tags":[]},{"location":"troubleshooting/simulation/#symptom_2","level":3,"title":"Symptom","text":"<p><code>remove_object</code> returns \"Object is referenced by other objects\".</p>","path":["Troubleshooting","Modeling &amp; Simulation Troubleshooting"],"tags":[]},{"location":"troubleshooting/simulation/#fix-options","level":3,"title":"Fix options","text":"<ol> <li>Preferred: rewire references first.</li> <li>Last resort: <code>force=true</code>.</li> </ol>","path":["Troubleshooting","Modeling &amp; Simulation Troubleshooting"],"tags":[]},{"location":"troubleshooting/simulation/#no-output-variables-found","level":2,"title":"No Output Variables Found","text":"","path":["Troubleshooting","Modeling &amp; Simulation Troubleshooting"],"tags":[]},{"location":"troubleshooting/simulation/#symptom_3","level":3,"title":"Symptom","text":"<p><code>list_output_variables</code> returns missing index error.</p>","path":["Troubleshooting","Modeling &amp; Simulation Troubleshooting"],"tags":[]},{"location":"troubleshooting/simulation/#causes","level":3,"title":"Causes","text":"<ul> <li>simulation failed early</li> <li>output metadata files were not produced</li> </ul>","path":["Troubleshooting","Modeling &amp; Simulation Troubleshooting"],"tags":[]},{"location":"troubleshooting/simulation/#fix_1","level":3,"title":"Fix","text":"<ul> <li>Inspect <code>get_results_summary</code> errors first.</li> <li>correct model issues and rerun simulation.</li> </ul>","path":["Troubleshooting","Modeling &amp; Simulation Troubleshooting"],"tags":[]},{"location":"workflows/claude/","level":1,"title":"Claude Workflow","text":"<p>This guide focuses on reliable tool-driven sessions in Claude clients.</p>","path":["Agent Workflows","Claude Workflow"],"tags":[]},{"location":"workflows/claude/#session-contract","level":2,"title":"Session Contract","text":"<p>Use this instruction style in Claude projects:</p> <pre><code>When editing EnergyPlus models, use idfkit-mcp tools instead of raw file edits.\nBefore writing: describe_object_type.\nAfter writing: validate_model and check_references.\nFor simulation: ensure weather source first, then run_simulation.\n</code></pre>","path":["Agent Workflows","Claude Workflow"],"tags":[]},{"location":"workflows/claude/#suggested-conversation-pattern","level":2,"title":"Suggested Conversation Pattern","text":"<ol> <li>Intent framing</li> <li>\"Target: reduce heating loads in perimeter zones\"</li> <li>Model context pull</li> <li><code>get_model_summary</code></li> <li><code>list_objects(object_type=\"Zone\")</code></li> <li>Schema-first changes</li> <li><code>describe_object_type</code> for edited types</li> <li>Implementation</li> <li><code>batch_add_objects</code> and <code>update_object</code></li> <li>Safety checks</li> <li><code>validate_model</code></li> <li><code>check_references</code></li> <li>Simulation + analysis</li> <li><code>download_weather_file</code></li> <li><code>run_simulation</code></li> <li><code>get_results_summary</code></li> </ol>","path":["Agent Workflows","Claude Workflow"],"tags":[]},{"location":"workflows/claude/#failure-recovery-pattern","level":2,"title":"Failure Recovery Pattern","text":"<p>When a call returns <code>{\"error\": ...}</code>:</p> <ol> <li>Keep prior successful steps unchanged.</li> <li>Read error details and adjust arguments.</li> <li>Re-run only failed step.</li> <li>Re-run validation after any fix.</li> </ol>","path":["Agent Workflows","Claude Workflow"],"tags":[]},{"location":"workflows/claude/#example-claude-prompt","level":2,"title":"Example Claude Prompt","text":"<pre><code>Use idfkit-mcp to inspect and improve this model.\nWorkflow: summarize current model, add missing zone objects, validate,\nresolve dangling references, save as ./out/fixed.idf,\nrun annual simulation with weather for Boston, and report key errors.\n</code></pre>","path":["Agent Workflows","Claude Workflow"],"tags":[]},{"location":"workflows/codex/","level":1,"title":"Codex Workflow","text":"<p>This pattern optimizes <code>idfkit-mcp</code> usage for Codex-style autonomous coding sessions.</p>","path":["Agent Workflows","Codex Workflow"],"tags":[]},{"location":"workflows/codex/#recommended-system-prompt-fragment","level":2,"title":"Recommended System Prompt Fragment","text":"<pre><code>Use idfkit-mcp to edit and simulate EnergyPlus models.\nAlways:\n1) call get_model_summary first,\n2) call describe_object_type before create/update,\n3) validate after each edit batch,\n4) prefer batch_add_objects over repeated add_object calls,\n5) summarize errors with actionable fixes.\n</code></pre>","path":["Agent Workflows","Codex Workflow"],"tags":[]},{"location":"workflows/codex/#high-throughput-authoring-loop","level":2,"title":"High-Throughput Authoring Loop","text":"<ol> <li>Load or create model (<code>load_model</code> / <code>new_model</code>)</li> <li>Fetch type contract (<code>describe_object_type</code>)</li> <li>Create objects in bulk (<code>batch_add_objects</code>)</li> <li>Wire references (<code>get_available_references</code>, <code>update_object</code>)</li> <li>Run guards (<code>validate_model</code>, <code>check_references</code>)</li> <li>Persist (<code>save_model</code>)</li> </ol>","path":["Agent Workflows","Codex Workflow"],"tags":[]},{"location":"workflows/codex/#simulation-loop","level":2,"title":"Simulation Loop","text":"<ol> <li>Ensure weather (<code>download_weather_file</code> or explicit <code>weather_file</code>)</li> <li>Run (<code>run_simulation</code>)</li> <li>Inspect (<code>get_results_summary</code>)</li> <li>Query variables (<code>list_output_variables</code>)</li> <li>Iterate from schema + validation findings</li> </ol>","path":["Agent Workflows","Codex Workflow"],"tags":[]},{"location":"workflows/codex/#prompting-tips-for-better-tool-use","level":2,"title":"Prompting Tips for Better Tool Use","text":"<ul> <li>Ask for diff-oriented updates: \"Change only these fields.\"</li> <li>Ask for batched object creation: \"Create all schedules in one call.\"</li> <li>Ask for structured exit criteria:</li> <li>model validates</li> <li>no dangling references</li> <li>simulation completes without severe/fatal errors</li> </ul>","path":["Agent Workflows","Codex Workflow"],"tags":[]},{"location":"workflows/codex/#example-task-brief","level":2,"title":"Example Task Brief","text":"<pre><code>Load ./models/baseline.idf, add 4 perimeter zones, update references,\nrun validation and dangling reference checks, save to ./models/revised.idf,\nthen run design-day simulation and summarize severe/fatal messages.\n</code></pre>","path":["Agent Workflows","Codex Workflow"],"tags":[]},{"location":"workflows/multi-agent-patterns/","level":1,"title":"Multi-Agent Patterns","text":"<p>This page describes team-style workflows where multiple agents collaborate on one model lifecycle.</p>","path":["Agent Workflows","Multi-Agent Patterns"],"tags":[]},{"location":"workflows/multi-agent-patterns/#pattern-1-planner-executor","level":2,"title":"Pattern 1: Planner + Executor","text":"<ul> <li>Planner agent:</li> <li>decides object types and sequence</li> <li>produces a batched action list</li> <li>Executor agent:</li> <li>runs <code>idfkit-mcp</code> tools</li> <li>captures outputs and failures</li> </ul> <p>Best practice:</p> <ul> <li>Planner must emit schema checks before every write action.</li> </ul>","path":["Agent Workflows","Multi-Agent Patterns"],"tags":[]},{"location":"workflows/multi-agent-patterns/#pattern-2-author-verifier","level":2,"title":"Pattern 2: Author + Verifier","text":"<ul> <li>Author agent:</li> <li>performs <code>add_object</code>, <code>batch_add_objects</code>, <code>update_object</code></li> <li>Verifier agent:</li> <li>runs <code>validate_model</code>, <code>check_references</code></li> <li>blocks merge if invalid</li> </ul> <p>Gate criteria:</p> <ul> <li><code>is_valid == true</code></li> <li><code>dangling_count == 0</code></li> </ul>","path":["Agent Workflows","Multi-Agent Patterns"],"tags":[]},{"location":"workflows/multi-agent-patterns/#pattern-3-modeling-simulation-split","level":2,"title":"Pattern 3: Modeling + Simulation Split","text":"<ul> <li>Modeling lane edits IDF/epJSON structures.</li> <li>Simulation lane handles weather selection and execution.</li> </ul> <p>Handoff contract:</p> <ol> <li>Modeling lane saves artifact path.</li> <li>Simulation lane loads same path with <code>load_model</code>.</li> <li>Simulation lane returns summary plus severe/fatal messages.</li> </ol>","path":["Agent Workflows","Multi-Agent Patterns"],"tags":[]},{"location":"workflows/multi-agent-patterns/#minimal-orchestration-checklist","level":2,"title":"Minimal Orchestration Checklist","text":"<ol> <li>Single source of truth path for model files.</li> <li>Explicit version pin (<code>new_model(version=...)</code> when creating).</li> <li>Validation checkpoint after every mutation batch.</li> <li>Simulation checkpoint before reporting results.</li> </ol>","path":["Agent Workflows","Multi-Agent Patterns"],"tags":[]}]}